<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="../../imgs/favicon.png" type="image/x-icon">
    <link rel="stylesheet" href="../../style/main.css">
    <title>Struct Padding & Alignment - Learning Guide</title>
</head>
<body>
        <header>
        <div class="container">
            <div class="header-content">
                <div class="header-title">
                    <h1>Struct Padding & Alignment</h1>
                    <div class="author-info">By sel-mlil</div>
                </div>
                <div class="header-nav">
                    <a href="../../" class="back-to-index">
                        Back to Index
                    </a>
                    <button class="theme-toggle" onclick="toggleTheme()">üåô Dark Mode</button>
                </div>
            </div>
        </div>
    </header>
        <nav>
        <div class="container">
            <div class="guide-nav-grid">
                <a class="guide-nav-item" href="#hook" data-section="0">üéØ The Hook</a>
                <a class="guide-nav-item" href="#mechanics" data-section="1">‚öôÔ∏è How It Works</a>
                <a class="guide-nav-item" href="#examples" data-section="2">üåç Real Examples</a>
                <a class="guide-nav-item" href="#practice" data-section="3">üõ†Ô∏è Do This Now</a>
                <a class="guide-nav-item" href="#warnings" data-section="4">‚ö†Ô∏è Avoid These</a>
                <a class="guide-nav-item" href="#connections" data-section="5">üîó Connections</a>
                <a class="guide-nav-item" href="#test" data-section="6">üéØ Test Yourself</a>
                <a class="guide-nav-item" href="#growth" data-section="7">üìà Level Up</a>
            </div>
        </div>
    </nav>
        <main class="container">
        <section id="hook">
            <div class="section-header">
                <div class="section-icon hook">üéØ</div>
                <h2 class="section-title">THE HOOK</h2>
            </div>
            <div class="content">
                <p><strong>What is this?</strong><br>Struct padding and alignment are rules that determine how data is laid out in memory so the CPU can read it efficiently.</p>
                <p><strong>Why care?</strong><br>They directly affect <strong>memory usage, performance, and binary compatibility</strong> in C programs. Get it wrong, and you waste space or cause crashes (misaligned access).</p>
                <p><strong>Mental model:</strong><br>Think of it like a <strong>bookshelf</strong>: each shelf holds books of a certain fixed width. If you try to put a big book halfway across two shelves, you'll struggle to pull it out. Padding is the extra empty space added so each book starts neatly at the correct shelf boundary.</p>
            </div>
        </section>

        <section id="mechanics">
            <div class="section-header">
                <div class="section-icon mechanics">‚öôÔ∏è</div>
                <h2 class="section-title">HOW IT WORKS</h2>
            </div>
            <div class="content">
                <h3>Core mechanics</h3>
                <ul>
                    <li><strong>CPU word:</strong> 32-bit CPU = 4 bytes, 64-bit CPU = 8 bytes. Accessing aligned data takes 1 cycle, misaligned data may take multiple cycles or even cause a bus error.</li>
                    <li><strong>Members:</strong> Each member inside a struct is aligned independently.</li>
                    <li><strong>Arrays:</strong> Each element in an array of structs must align properly, so the <em>stride</em> (element size) is the padded struct size.</li>
                    <li><strong>Nested structs:</strong> Alignment rules propagate ‚Äî the nested struct behaves like a member with its own alignment requirements.</li>
                </ul>
                <h3>Governing principles</h3>
                <ol>
                    <li>Each member starts at an offset that is a multiple of its alignment.</li>
                    <li>Padding is added between members as needed.</li>
                    <li>Total struct size is padded to be a multiple of the largest alignment.</li>
                </ol>
            </div>
        </section>

        <section id="examples">
            <div class="section-header">
                <div class="section-icon examples">üåç</div>
                <h2 class="section-title">REAL EXAMPLES</h2>
            </div>
            <div class="content">
                <h3>Simple case</h3>
                <div class="code-block">
                    <pre>struct A {
    char c;  // 1 byte
    int i;   // 4 bytes
};</pre>
                </div>
                <p>On 32-bit or 64-bit:</p>
                <ul>
                    <li><code>c</code> at offset 0</li>
                    <li>3 bytes padding</li>
                    <li><code>i</code> at offset 4‚Äì7</li>
                    <li><strong>Struct size = 8 bytes (not 5).</strong></li>
                </ul>
                <h3>Professional use</h3>
                <div class="code-block">
                    <pre>struct B {
    char c;   // 1
    char d;   // 1
    int i;    // 4
};</pre>
                </div>
                <p>Layout:</p>
                <ul>
                    <li><code>c</code> offset 0</li>
                    <li><code>d</code> offset 1</li>
                    <li>2 bytes padding</li>
                    <li><code>i</code> offset 4‚Äì7</li>
                    <li><strong>Size = 8 bytes</strong>.</li>
                </ul>
                <p>Efficient if reordered:</p>
                <div class="code-block">
                    <pre>struct B_opt {
    int i;    // 4
    char c;   // 1
    char d;   // 1
}; // size = 8 but better packing for arrays</pre>
                </div>
                <h3>Edge case: Arrays & nested structs</h3>
                <div class="code-block">
                    <pre>struct Point {
    char c;
    int i;
};
struct Shape {
    int id;
    struct Point p;
};</pre>
                </div>
                <ul>
                    <li><code>Point</code> size = 8 (due to padding).</li>
                    <li><code>Shape</code>: <ul><li><code>id</code> at offset 0‚Äì3</li><li>padding 4‚Äì7</li><li><code>p</code> at offset 8‚Äì15</li><li><strong>Size = 16 bytes</strong>, not 12.</li></ul></li>
                </ul>
                <p>For an array:</p>
                <div class="code-block">
                    <pre>struct Point arr[3];</pre>
                </div>
                <p>Each element takes 8 bytes, so total = 24 bytes. Padding ensures each <code>i</code> stays 4-byte aligned.</p>
            </div>
        </section>

        <section id="practice">
            <div class="section-header">
                <div class="section-icon practice">üõ†Ô∏è</div>
                <h2 class="section-title">DO THIS NOW</h2>
            </div>
            <div class="content">
                <div class="action-box">
                <ol>
                    <li>Write a small C program:</li>
                </ol>
                <div class="code-block">
                    <pre>#include <stdio.h>

struct X { char c; int i; };
struct Y { int i; char c; };

int main() {
    printf("sizeof(struct X) = %zu\n", sizeof(struct X));
    printf("sizeof(struct Y) = %zu\n", sizeof(struct Y));
}</pre>
                </div>
                <ol start="2">
                    <li>Compile and run.</li>
                    <li>Notice how both are 8, but layouts differ (you can confirm with <code>offsetof</code>).</li>
                </ol>
                <p><strong>What to look for:</strong> The difference between field order and struct size.<br><strong>Quick win:</strong> See that reordering fields doesn't always reduce size, but often improves cache efficiency.</p>
                </div>
            </div>
        </section>

        <section id="warnings">
            <div class="section-header">
                <div class="section-icon warnings">‚ö†Ô∏è</div>
                <h2 class="section-title">AVOID THESE</h2>
            </div>
            <div class="content">
                <div class="warning-box">
                <ul>
                    <li><strong>Assuming struct size = sum of members</strong> ‚Üí Always check <code>sizeof</code>.</li>
                    <li><strong>Forgetting about arrays of structs</strong> ‚Üí Padding inside one element gets multiplied across the array.</li>
                    <li><strong>Embedding structs blindly</strong> ‚Üí Nested structs carry their alignment rules into parents.</li>
                </ul>
                </div>
            </div>
        </section>

        <section id="connections">
            <div class="section-header">
                <div class="section-icon connections">üîó</div>
                <h2 class="section-title">CONNECTIONS</h2>
            </div>
            <div class="content">
                <ul>
                    <li><strong>Prerequisites:</strong> Pointers, memory addressing, word size.</li>
                    <li><strong>Related concepts:</strong> Cache lines, ABI (Application Binary Interface), <code>#pragma pack</code> / <code>__attribute__((packed))</code>.</li>
                    <li><strong>Next steps:</strong> Study how padding interacts with bitfields, unions, and serialization.</li>
                </ul>
            </div>
        </section>

        <section id="test">
            <div class="section-header">
                <div class="section-icon test">üéØ</div>
                <h2 class="section-title">TEST YOURSELF</h2>
            </div>
            <div class="content">
                <ol>
                    <li>Why does <code>sizeof(struct {char c; int i;})</code> equal 8, not 5?</li>
                    <li>What happens to array size when padding is inside the struct?</li>
                    <li>How does the largest member influence total struct size?</li>
                </ol>
                <p><strong>Success criteria:</strong> You can predict struct size and explain why padding appears.<br><strong>Review triggers:</strong> Any time you serialize structs across systems (e.g., networking, file formats).</p>
            </div>
        </section>

        <section id="growth">
            <div class="section-header">
                <div class="section-icon growth">üìà</div>
                <h2 class="section-title">LEVEL UP</h2>
            </div>
            <div class="content">
                <ul>
                    <li><strong>This week:</strong> Experiment with <code>sizeof</code> and <code>offsetof</code> for different struct layouts.</li>
                    <li><strong>This month:</strong> Learn ABI rules for your platform (x86, ARM).</li>
                    <li><strong>Long term:</strong> Master cache-aware struct design, packed structs for networking, and alignment for SIMD/vectorization.</li>
                </ul>
            </div>
        </section>
    </main>
        <footer>
        <div class="container">
            <p>Learning journey completed! üéâ</p>
            <div class="checkbox-item" style="justify-content: center; margin-top: 1rem;">
                <div class="checkbox" onclick="toggleComplete(this)"></div>
                <span>Mark this topic as mastered</span>
            </div>
        </div>
    </footer>
        <script>
        // Theme toggle
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            
            // Update button text
            updateThemeButton(newTheme);
        }

        // Update theme button text based on current theme
        function updateThemeButton(currentTheme) {
            const button = document.querySelector('.theme-toggle');
            if (currentTheme === 'dark') {
                button.innerHTML = '‚òÄÔ∏è Light Mode';
            } else {
                button.innerHTML = 'üåô Dark Mode';
            }
        }

        // Load saved theme
        function loadTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeButton(savedTheme);
        }

        // Initialize theme on page load
        document.addEventListener('DOMContentLoaded', loadTheme);

        // Section completion
        document.querySelectorAll('.nav-item').forEach(item => {
            item.addEventListener('click', function() {
                this.classList.toggle('completed');
                const completedSections = Array.from(document.querySelectorAll('.nav-item.completed'))
                    .map(el => el.getAttribute('data-section'));
                localStorage.setItem('completed-struct-padding---alignment', JSON.stringify(completedSections));
            });
        });

        // Load saved progress
        const savedProgress = localStorage.getItem('completed-struct-padding---alignment');
        if (savedProgress) {
            const completed = JSON.parse(savedProgress);
            completed.forEach(sectionNum => {
                const navItem = document.querySelector(`[data-section="${sectionNum}"]`);
                if (navItem) navItem.classList.add('completed');
            });
        }

        // Checkbox functionality
        function toggleComplete(checkbox) {
            checkbox.classList.toggle('checked');
            if (checkbox.classList.contains('checked')) {
                checkbox.innerHTML = '‚úì';
                localStorage.setItem('mastered-struct-padding---alignment', 'true');
            } else {
                checkbox.innerHTML = '';
                localStorage.setItem('mastered-struct-padding---alignment', 'false');
            }
        }

        // Load mastery status
        const masteryStatus = localStorage.getItem('mastered-struct-padding---alignment');
        if (masteryStatus === 'true') {
            const masteryCheckbox = document.querySelector('footer .checkbox');
            if (masteryCheckbox) {
                masteryCheckbox.classList.add('checked');
                masteryCheckbox.innerHTML = '‚úì';
            }
        }

        // Smooth scrolling
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            });
        });
    </script>
</body>
</html>