<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="../../imgs/favicon.png" type="image/x-icon">
    <link rel="stylesheet" href="../../style/main.css">
    
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/darcula.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/default.min.css">
    
    <!-- CodeMirror JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/clike/clike.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/shell/shell.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/css/css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/htmlmixed/htmlmixed.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/selection/active-line.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/matchbrackets.min.js"></script>
    
    <title>CPP STL Containers: Vector and Map Mastery Guide - Learning Guide</title>
</head>
<body>
        <header>
        <div class="container">
            <div class="header-content">
                <div class="header-title">
                    <h1>CPP STL Containers: Vector and Map Mastery Guide</h1>
                    <div class="author-info">By sel-mlil</div>
                </div>
                <div class="header-nav">
                    <a href="../../" class="back-to-index">
                        Back to Index
                    </a>
                    <button class="theme-toggle" onclick="toggleTheme()">üåô Dark Mode</button>
                </div>
            </div>
        </div>
    </header>
        <nav>
        <div class="container">
            <div class="guide-nav-grid">
                <a class="guide-nav-item" href="#hook" data-section="0">üéØ The Hook</a>
                <a class="guide-nav-item" href="#concept" data-section="1">üí° Core Concepts (STL)</a>
                <a class="guide-nav-item" href="#mechanics" data-section="2">‚öôÔ∏è How Vector and Map Work</a>
                <a class="guide-nav-item" href="#examples" data-section="3">üåç Real Examples (Complex Use Cases)</a>
                <a class="guide-nav-item" href="#practice" data-section="4">üõ†Ô∏è DO THIS NOW (Mastery Tasks)</a>
                <a class="guide-nav-item" href="#debugging" data-section="5">üêõ Debugging & Troubleshooting</a>
                <a class="guide-nav-item" href="#performance" data-section="6">üöÄ Performance & Optimization</a>
                <a class="guide-nav-item" href="#warnings" data-section="7">‚ö†Ô∏è AVOID THESE (Critical Pitfalls)</a>
                <a class="guide-nav-item" href="#advanced" data-section="8">üéì Advanced Topics (Customization)</a>
                <a class="guide-nav-item" href="#test" data-section="9">üéØ Test Yourself</a>
                <a class="guide-nav-item" href="#growth" data-section="10">üìà LEVEL UP</a>
            </div>
        </div>
    </nav>
        <main class="container">
        <section id="hook">
            <div class="section-header">
                <div class="section-icon hook">üéØ</div>
                <h2 class="section-title">THE HOOK</h2>
            </div>
            <div class="content">
                <p><strong>What is this?</strong><br>The <strong>Standard Template Library (STL)</strong> is the foundational toolkit for C++ data management. Mastering <code>std::vector</code> (the dynamic, contiguous array) and <code>std::map</code> (the ordered, tree-based key-value store) is the single most critical step toward C++ competency, especially in C++98 environments.</p>
                <p><strong>Why care?</strong><br>These containers define the performance profile of your application. Choosing correctly between the $O(1)$ indexed access of a vector and the $O(\log N)$ associative access of a map is the difference between scalable and slow software.</p>
                <p><strong>Mental model:</strong><br>The <strong>Vector</strong> is like a <strong>parking garage</strong>: every spot is numbered (index) and contiguous, making access instant, but expanding it means building a whole new, bigger structure and moving all the cars. The <strong>Map</strong> is like a <strong>library catalog (Red-Black Tree)</strong>: items are kept sorted, and finding or adding a book takes predictable, logarithmic time, regardless of where it is.</p>
            </div>
        </section>

        <section id="concept">
            <div class="section-header">
                <div class="section-icon concept">üí°</div>
                <h2 class="section-title">Core Concepts (STL)</h2>
            </div>
            <div class="content">
                <h3>The Container Contract</h3>
                <ul>
                    <li><strong>Templates & Genericity:</strong> Containers are reusable blueprints that work with any data type (e.g., <code>vector&lt;int&gt;</code>, <code>map&lt;string, float&gt;</code>).</li>
                    <li><strong>Automatic Memory Management:</strong> They handle internal memory allocation/deallocation, preventing common C-style array bugs and leaks.</li>
                    <li><strong>Iterators:</strong> Generalized pointer-like objects (<code>begin()</code>, <code>end()</code>) used to traverse and access elements. Iterators are the <strong>glue</strong> that connects containers to STL algorithms like <code>std::sort</code> and <code>std::find</code>.</li>
                </ul>
                <h3>Categories and Access</h3>
                <ul>
                    <li><strong>Sequence Containers (std::vector):</strong> Store elements in contiguous memory. Key access feature: <strong>Random Access</strong> (via index, $O(1)$).</li>
                    <li><strong>Associative Containers (std::map):</strong> Store elements as nodes in a sorted tree structure. Key access feature: <strong>Associative Lookup</strong> (via key, $O(\log N)$).</li>
                </ul>
            </div>
        </section>

        <section id="mechanics">
            <div class="section-header">
                <div class="section-icon mechanics">‚öôÔ∏è</div>
                <h2 class="section-title">HOW IT WORKS</h2>
            </div>
            <div class="content">
                <h3>std::vector Deep Dive: Capacity and Reallocation</h3>
                <ul>
                    <li><strong>Contiguous Storage:</strong> Essential for cache efficiency and for compatibility with C APIs (e.g., <code>&vec[0]</code> gives the starting address).</li>
                    <li><strong><code>size()</code> vs <code>capacity()</code>:</strong> <code>size()</code> is the number of elements; <code>capacity()</code> is the total allocated space. When <code>size()</code> == <code>capacity()</code>, the next <code>push_back</code> triggers <strong>Reallocation</strong>. The new capacity is typically the old capacity multiplied by 1.5 or 2.</li>
                    <li><strong>Amortized Complexity:</strong> While a single reallocation is $O(N)$ (copying all $N$ elements), it happens infrequently. Over many operations, the average cost of <code>push_back</code> is considered <strong>Amortized $O(1)$</strong>.</li>
                </ul>
                <h3>std::map Deep Dive: Red-Black Tree Structure</h3>
                <ul>
                    <li><strong>Red-Black Tree (RBT):</strong> A self-balancing binary search tree. Every insertion/deletion operation may require <strong>rotations</strong> and <strong>color changes</strong> to ensure the tree remains balanced. This guarantees the maximum depth of the tree is logarithmic, hence $O(\log N)$ complexity.</li>
                    <li><strong>Memory Overhead:</strong> Unlike vector's compact memory, each map element (node) requires extra space for the key/value pair plus <strong>three pointers</strong> (parent, left child, right child) and a <strong>color bit</strong> (red/black). This makes map significantly less memory efficient than vector.</li>
                    <li><strong>Custom Keys:</strong> The key type <strong>must</strong> support the strict weak ordering required for sorting, typically achieved by overloading the <code>operator&lt;</code>.</li>
                </ul>
            </div>
        </section>

        <section id="examples">
            <div class="section-header">
                <div class="section-icon examples">üåç</div>
                <h2 class="section-title">REAL EXAMPLES (Complex Use Cases)</h2>
            </div>
            <div class="content">
                <h3>Vector: Pre-allocating and C-API Interoperability</h3>
                <p>Avoid costly reallocations by estimating size upfront (<code>reserve</code>) and safely passing data to legacy C functions that expect a raw pointer to an array (<code>&vec[0]</code>).</p>
                <div class="code-block" data-language="cpp">
                    <textarea id="code-n8lsdxwyz" class="codemirror-code">#include <vector>
#include <iostream>

void C_API_Process(int* data, int count);

int main() {
    std::vector<int> data_vec;
    const int N = 1000;
    
    // Optimize: Pre-allocate memory to hold 1000 elements
    data_vec.reserve(N);

    for (int i = 0; i < N; ++i) {
        data_vec.push_back(i * 2);
    }

    // C++98 safe way to get pointer to contiguous data:
    C_API_Process(&data_vec[0], data_vec.size()); 
    
    return 0;
}</textarea>
                </div>
                <h3>Map: Implementing a Custom Index with Overloaded Operators</h3>
                <p>Using a custom class as a map key requires defining <code>operator&lt;</code> for the map to correctly sort and locate keys within the Red-Black Tree.</p>
                <div class="code-block" data-language="cpp">
                    <textarea id="code-8hfserxpc" class="codemirror-code">#include <map>
#include <string>

class KeyCoordinate {
public:
    int x, y;
    KeyCoordinate(int _x, int _y) : x(_x), y(_y) {}
    
    // Required for map: Defines the strict weak ordering
    bool operator<(const KeyCoordinate& other) const {
        if (x != other.x) {
            return x < other.x;
        }
        return y < other.y;
    }
};

int main() {
    std::map<KeyCoordinate, std::string> point_data;
    
    point_data.insert(std::make_pair(KeyCoordinate(10, 5), "Sector A"));
    point_data.insert(std::make_pair(KeyCoordinate(1, 1), "Origin"));
    
    // Lookup uses the overloaded operator<
    std::string data = point_data.find(KeyCoordinate(10, 5))->second;
    // data == "Sector A"
    
    return 0;
}</textarea>
                </div>
            </div>
        </section>

        <section id="practice">
            <div class="section-header">
                <div class="section-icon practice">üõ†Ô∏è</div>
                <h2 class="section-title">DO THIS NOW (Mastery Tasks)</h2>
            </div>
            <div class="content">
                <div class="action-box">
                <ol>
                    <li><strong>Vector: Performance Challenge:</strong> Write a loop that adds 100,000 elements to a vector. Measure the time taken. Repeat the test, but this time, call <code>reserve(100000)</code> before the loop. Compare the runtimes and explain the difference in terms of reallocation cost.</li>
                    <li><strong>Vector: Iterator Invalidation:</strong> Write a loop that iterates over a vector and conditionally erases elements. Ensure you handle iterator advancement correctly after the <code>erase()</code> call to avoid a crash. The <code>erase()</code> member function returns a valid iterator to the element following the erased one.</li>
                    <li><strong>Map: Safe Insertion:</strong> Implement a function that attempts to insert a key-value pair into a map and prints whether the insertion was successful or if the key already existed, using the <code>insert()</code> member function's returned <code>std::pair</code>.</li>
                </ol>
                <p><strong>What to look for:</strong> The `reserve()` version should be significantly faster (eliminating $O(N)$ copies). Iterator handling after `erase()` must be `it = vec.erase(it);` or similar, not `it++;`. Successful map insertion check requires accessing the `second` element of the returned pair.<br><strong>Quick win:</strong> Successfully implementing the iterator-safe vector erase pattern.</p>
                </div>
            </div>
        </section>

        <section id="debugging">
            <div class="section-header">
                <div class="section-icon debugging">üêõ</div>
                <h2 class="section-title">Debugging & Troubleshooting</h2>
            </div>
            <div class="content">
                <h3>Vector Troubleshooting</h3>
                <ul>
                    <li><strong>Segmentation Faults:</strong> Almost always caused by <strong>accessing memory outside the vector's bounds</strong>. This happens when using the unchecked <code>[]</code> operator or by using an invalidated iterator. <strong>Fix:</strong> Use <code>vec.at(i)</code> for checked access (throws an exception) or check loop conditions against <code>vec.size()</code> and use a debugger to inspect iterator state.</li>
                    <li><strong>Slow Performance:</strong> Frequent <code>push_back</code> operations without initial <code>reserve()</code> are a classic performance issue. <strong>Fix:</strong> Profile code to check for high reallocation time, then pre-allocate memory.</li>
                </ul>
                <h3>Map Troubleshooting</h3>
                <ul>
                    <li><strong>Unexpected Insertion:</strong> Using <code>map[key]</code> when trying to read a non-existent key will silently default-construct the value (e.g., <code>0</code> for <code>int</code>, empty string for <code>std::string</code>) and insert the key. <strong>Fix:</strong> Use <code>map.find(key)</code> for lookup only.</li>
                    <li><strong>Key Comparison Bugs:</strong> If a custom key object is used, the <code>operator&lt;</code> implementation must be mathematically correct (must satisfy strict weak ordering, e.g., non-reflexive, anti-symmetric, and transitive). <strong>Fix:</strong> Thoroughly test the custom <code>operator&lt;</code>.</li>
                </ul>
            </div>
        </section>

        <section id="performance">
            <div class="section-header">
                <div class="section-icon performance">üöÄ</div>
                <h2 class="section-title">Performance & Optimization</h2>
            </div>
            <div class="content">
                <h3>Vector Performance ($O(1)$ Dominance)</h3>
                <ul>
                    <li><strong>Optimization 1: <code>reserve()</code>:</strong> Essential for write-heavy vectors. It trades one large $O(N)$ allocation upfront for many small $O(1)$ writes later, drastically improving average write speed.</li>
                    <li><strong>Optimization 2: Cache Locality:</strong> Since elements are contiguous, when the CPU accesses <code>vec[i]</code>, the next few elements (<code>vec[i+1]</code>, <code>vec[i+2]</code>) are often pulled into the cache automatically. This makes sequential iteration and indexed lookups extremely fast.</li>
                    <li><strong>Complexity Summary:</strong> Random access: $O(1)$. Insert/Erase at end: Amortized $O(1)$. Insert/Erase elsewhere: $O(N)$.</li>
                </ul>
                <h3>Map Performance ($O(\log N)$ Consistency)</h3>
                <ul>
                    <li><strong>Consistent Time:</strong> The $O(\log N)$ complexity for all main operations (find, insert, erase) is highly desirable because it means performance gracefully degrades as $N$ grows, without sudden drops. For 1 million items, $\log_2(1,000,000)$ is about 20 comparisons.</li>
                    <li><strong>No Cache Locality:</strong> Map nodes are scattered across the heap (non-contiguous memory). Iterating over a map involves many <strong>cache misses</strong> (jumping memory locations), making map iteration much slower than vector iteration, despite the $O(N)$ complexity being the same for both.</li>
                    <li><strong>Optimization:</strong> If you only need a lookup table and don't require the keys to be sorted, consider using a faster alternative like <strong><code>std::hash_map</code></strong> (or <code>std::tr1::unordered_map</code> if available in your C++98 library), which offers average $O(1)$ lookup.</li>
                </ul>
            </div>
        </section>

        <section id="warnings">
            <div class="section-header">
                <div class="section-icon warnings">‚ö†Ô∏è</div>
                <h2 class="section-title">AVOID THESE (Critical Pitfalls)</h2>
            </div>
            <div class="content">
                <div class="warning-box">
                <ul>
                    <li><strong>Vector: Iterator Invalidation on Reallocation</strong> ‚Üí Never use an iterator after calling `push_back()` or `reserve()` (unless it's the returned iterator from `erase()`). The underlying memory block may have moved.</li>
                    <li><strong>Vector: Using `&vec[0]` after Modification</strong> ‚Üí If you pass the base pointer to a C function, <strong>do not</strong> modify the vector's size (e.g., <code>push_back</code>) while the C function is running, as this might corrupt the C function's pointer.</li>
                    <li><strong>Map: Modifying Key Data</strong> ‚Üí The Key in a `map` element is internally `const` (even if you don't explicitly write `const`). Attempting to change the key through a pointer or reference is undefined behavior, as it breaks the tree's sorted structure.</li>
                    <li><strong>Map: Over-reliance on Default Value</strong> ‚Üí Using `map[non_existent_key]` to read will insert a new element. If this happens in a tight loop, it can cause performance degradation and unexpected data growth.</li>
                </ul>
                </div>
            </div>
        </section>

        <section id="advanced">
            <div class="section-header">
                <div class="section-icon advanced">üéì</div>
                <h2 class="section-title">Advanced Topics (Customization)</h2>
            </div>
            <div class="content">
                <h3>Vector: The Allocator</h3>
                <p>Both containers take an optional <strong>Allocator</strong> template argument (usually left as <code>std::allocator</code>). For mastery, you should know you can substitute your own custom allocator to manage memory from a specific pool (e.g., shared memory or a fixed-size buffer) instead of the global heap. This is crucial for high-performance and embedded systems.</p>
                <h3>Map: Custom Comparison</h3>
                <p>Instead of overloading <code>operator&lt;</code> for a custom key type, you can pass a custom <strong>Comparator</strong> (a function object or struct with an overloaded <code>operator()</code>) as the third template argument to <code>std::map</code>. This allows you to define complex sorting rules without touching the key class definition.</p>
                <div class="code-block" data-language="cpp">
                    <textarea id="code-00bvsvgmc" class="codemirror-code">struct ReverseIntCompare {
    bool operator()(const int& a, const int& b) const {
        return a > b; // Sorts keys in descending order
    }
};

// Keys will be stored from largest to smallest
std::map<int, std::string, ReverseIntCompare> descending_map;</textarea>
                </div>
            </div>
        </section>

        <section id="test">
            <div class="section-header">
                <div class="section-icon test">üéØ</div>
                <h2 class="section-title">TEST YOURSELF</h2>
            </div>
            <div class="content">
                <ol>
                    <li><strong>Complexity Analysis:</strong> Write down the Big O complexity for <code>map.insert()</code>, <code>vector.at()</code>, and <code>vector.insert(vec.begin(), item)</code>. Justify each.</li>
                    <li><strong>Memory Trade-off:</strong> Explain why, in terms of memory overhead, a <code>std::vector&lt;int&gt;</code> is often preferred over a <code>std::map&lt;int, int&gt;</code> for small $N$.</li>
                    <li><strong>Code Debug:</strong> Identify and fix the iterator-related error in the following C++98 code: <code>for (it = vec.begin(); it != vec.end(); it++) { vec.push_back(1); }</code></li>
                    <li><strong>Design Problem:</strong> You need a collection to store millions of customer records, accessed only by a unique ID, and the access must be $O(1)$ (average). Which standard C++98 container is best, and which advanced (non-standard) container is the true professional choice (if available)? (Hint: Think about sorting.)</li>
                </ol>
                <p><strong>Success criteria:</strong> Correctly identify the $O(N)$ complexity for vector front insertion and understand the role of `std::hash_map` (or `std::tr1::unordered_map`) as the $O(1)$ average solution for key-value lookups.<br><strong>Review triggers:</strong> Any failure to describe the purpose of `vector::reserve()` or the cost of map's non-contiguous memory.</p>
            </div>
        </section>

        <section id="growth">
            <div class="section-header">
                <div class="section-icon growth">üìà</div>
                <h2 class="section-title">LEVEL UP</h2>
            </div>
            <div class="content">
                <ul>
                    <li><strong>This week (Iterators):</strong> Practice using the full range of STL algorithms (`std::sort`, `std::unique`, `std::transform`) on both `std::vector` and `std::map` iterators. Understand why some algorithms only work on `std::vector`.</li>
                    <li><strong>This month (Customization):</strong> Implement a `std::map` using a custom class as the key, ensuring the required `operator<` is correctly defined and tested for edge cases.</li>
                    <li><strong>Long term (Expertise):</strong> Write a custom Allocator class and use it to instantiate both a `std::vector` and a `std::map`. Benchmark the performance against the default global allocator in a resource-constrained scenario.</li>
                </ul>
            </div>
        </section>
    </main>
        <footer>
        <div class="container">
            <p>Learning journey completed! üéâ</p>
            <div class="checkbox-item" style="justify-content: center; margin-top: 1rem;">
                <div class="checkbox" onclick="toggleComplete(this)"></div>
                <span>Mark this topic as mastered</span>
            </div>
        </div>
    </footer>
        <script>
        // Theme toggle
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            
            // Update button text
            updateThemeButton(newTheme);
        }

        // Update theme button text based on current theme
        function updateThemeButton(currentTheme) {
            const button = document.querySelector('.theme-toggle');
            if (currentTheme === 'dark') {
                button.innerHTML = '‚òÄÔ∏è Light Mode';
            } else {
                button.innerHTML = 'üåô Dark Mode';
            }
        }

        // Load saved theme
        function loadTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeButton(savedTheme);
        }

        // Initialize theme on page load
        document.addEventListener('DOMContentLoaded', loadTheme);

        // Section completion
        document.querySelectorAll('.nav-item').forEach(item => {
            item.addEventListener('click', function() {
                this.classList.toggle('completed');
                const completedSections = Array.from(document.querySelectorAll('.nav-item.completed'))
                    .map(el => el.getAttribute('data-section'));
                localStorage.setItem('completed-cpp-stl-containers--vector-and-map-mastery-guide', JSON.stringify(completedSections));
            });
        });

        // Load saved progress
        const savedProgress = localStorage.getItem('completed-cpp-stl-containers--vector-and-map-mastery-guide');
        if (savedProgress) {
            const completed = JSON.parse(savedProgress);
            completed.forEach(sectionNum => {
                const navItem = document.querySelector(`[data-section="${sectionNum}"]`);
                if (navItem) navItem.classList.add('completed');
            });
        }

        // Checkbox functionality
        function toggleComplete(checkbox) {
            checkbox.classList.toggle('checked');
            if (checkbox.classList.contains('checked')) {
                checkbox.innerHTML = '‚úì';
                localStorage.setItem('mastered-cpp-stl-containers--vector-and-map-mastery-guide', 'true');
            } else {
                checkbox.innerHTML = '';
                localStorage.setItem('mastered-cpp-stl-containers--vector-and-map-mastery-guide', 'false');
            }
        }

        // Load mastery status
        const masteryStatus = localStorage.getItem('mastered-cpp-stl-containers--vector-and-map-mastery-guide');
        if (masteryStatus === 'true') {
            const masteryCheckbox = document.querySelector('footer .checkbox');
            if (masteryCheckbox) {
                masteryCheckbox.classList.add('checked');
                masteryCheckbox.innerHTML = '‚úì';
            }
        }

        // Smooth scrolling
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            });
        });

        // Initialize CodeMirror for all code blocks
        let initAttempts = 0;
        const maxAttempts = 50; // Max 5 seconds of retries
        
        function initializeCodeMirror() {
            initAttempts++;
            
            // Check if CodeMirror is loaded
            if (typeof CodeMirror === 'undefined') {
                if (initAttempts >= maxAttempts) {
                    console.error('Failed to load CodeMirror after', maxAttempts, 'attempts. Using fallback styling.');
                    // Fallback: Style textareas as basic code blocks
                    document.querySelectorAll('.codemirror-code').forEach(textarea => {
                        textarea.style.fontFamily = 'Monaco, Menlo, "Ubuntu Mono", monospace';
                        textarea.style.fontSize = '14px';
                        textarea.style.lineHeight = '1.5';
                        textarea.style.padding = '10px';
                        textarea.style.border = '1px solid var(--border)';
                        textarea.style.borderRadius = '4px';
                        textarea.style.background = 'var(--code-bg)';
                        textarea.style.color = 'var(--code-text)';
                        textarea.style.resize = 'none';
                        textarea.style.minHeight = '100px';
                        textarea.readOnly = true;
                    });
                    return;
                }
                console.warn('CodeMirror not loaded, retrying in 100ms... (attempt', initAttempts, '/', maxAttempts, ')');
                setTimeout(initializeCodeMirror, 100);
                return;
            }
            
            const codeTextareas = document.querySelectorAll('.codemirror-code');
            console.log('Initializing CodeMirror for', codeTextareas.length, 'code blocks');
            
            codeTextareas.forEach(textarea => {
                const codeBlock = textarea.closest('.code-block');
                const language = codeBlock.dataset.language;
                
                // Map language to CodeMirror mode
                let mode = 'text';
                switch(language) {
                    case 'c':
                    case 'cpp':
                    case 'c++':
                        mode = 'text/x-csrc';
                        break;
                    case 'javascript':
                    case 'js':
                        mode = 'javascript';
                        break;
                    case 'bash':
                    case 'shell':
                    case 'sh':
                        mode = 'shell';
                        break;
                    case 'css':
                        mode = 'css';
                        break;
                    case 'html':
                        mode = 'htmlmixed';
                        break;
                    case 'json':
                        mode = 'application/json';
                        break;
                    default:
                        mode = 'text';
                }
                
                // Use custom theme that respects CSS variables
                const cmTheme = 'default'; // We'll override with CSS
                
                try {
                    const editor = CodeMirror.fromTextArea(textarea, {
                        mode: mode,
                        theme: cmTheme,
                        lineNumbers: true,
                        readOnly: 'nocursor',  // Disable cursor and selection
                        lineWrapping: true,    // Enable line wrapping to avoid horizontal scroll
                        scrollbarStyle: 'null', // Remove scrollbars
                        viewportMargin: Infinity, // Show all content without scrolling
                        matchBrackets: false,  // Disable bracket matching highlights
                        styleActiveLine: false, // Disable active line highlighting
                        indentUnit: 4,
                        tabSize: 4
                    });
                    
                    // Store editor reference for theme switching
                    textarea.codeMirrorInstance = editor;
                    
                    // Auto-refresh editor size and ensure no scrollbars
                    setTimeout(() => {
                        editor.refresh();
                        editor.setSize(null, 'auto'); // Auto-height based on content
                    }, 100);
                    
                    console.log('CodeMirror initialized for language:', language, 'mode:', mode);
                } catch (error) {
                    console.error('Failed to initialize CodeMirror for textarea:', error);
                }
            });
        }
        
        // CodeMirror themes are handled by CSS variables, no need to update programmatically
        
        // Initialize CodeMirror when DOM and scripts are fully loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                // Wait a bit more for all scripts to load
                setTimeout(initializeCodeMirror, 200);
            });
        } else {
            // Document already loaded, wait for scripts
            setTimeout(initializeCodeMirror, 200);
        }
    </script>
</body>
</html>