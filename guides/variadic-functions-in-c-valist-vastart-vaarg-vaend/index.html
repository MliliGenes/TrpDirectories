<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="../../imgs/favicon.png" type="image/x-icon">
    <link rel="stylesheet" href="../../style/main.css">
    
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/darcula.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/default.min.css">
    
    <!-- CodeMirror JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/clike/clike.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/shell/shell.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/css/css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/htmlmixed/htmlmixed.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/selection/active-line.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/matchbrackets.min.js"></script>
    
    <title>Variadic Functions in C: va_list, va_start, va_arg, va_end - Learning Guide</title>
</head>
<body>
        <header>
        <div class="container">
            <div class="header-content">
                <div class="header-title">
                    <h1>Variadic Functions in C: va_list, va_start, va_arg, va_end</h1>
                    <div class="author-info">By sel-mlil</div>
                </div>
                <div class="header-nav">
                    <a href="../../" class="back-to-index">
                        Back to Index
                    </a>
                    <button class="theme-toggle" onclick="toggleTheme()">ğŸŒ™ Dark Mode</button>
                </div>
            </div>
        </div>
    </header>
        <nav>
        <div class="container">
            <div class="guide-nav-grid">
                <a class="guide-nav-item" href="#hook" data-section="0">ğŸ¯ The Hook</a>
                <a class="guide-nav-item" href="#concept" data-section="1">ğŸ’¡ Core Concepts</a>
                <a class="guide-nav-item" href="#mechanics" data-section="2">âš™ï¸ How It Works</a>
                <a class="guide-nav-item" href="#examples" data-section="3">ğŸŒ Real Examples</a>
                <a class="guide-nav-item" href="#practice" data-section="4">ğŸ› ï¸ Hands-On Practice</a>
                <a class="guide-nav-item" href="#warnings" data-section="5">âš ï¸ Common Pitfalls</a>
                <a class="guide-nav-item" href="#performance" data-section="6">ğŸš€ Registers & ABI Notes</a>
                <a class="guide-nav-item" href="#test" data-section="7">ğŸ¯ Test Yourself</a>
                <a class="guide-nav-item" href="#growth" data-section="8">ğŸ“ˆ Next Steps</a>
            </div>
        </div>
    </nav>
        <main class="container">
        <section id="hook">
            <div class="section-header">
                <div class="section-icon hook">ğŸ¯</div>
                <h2 class="section-title">THE HOOK</h2>
            </div>
            <div class="content">
                <p>Variadic functions let you accept a variable number of arguments â€” think printf. C provides a small API (va_list, va_start, va_arg, va_end) to walk those arguments. But using it correctly requires knowing about promotions and how arguments are passed at the ABI level.</p>
                <p>This guide shows practical usage, pitfalls, and a short peek under the hood so you don't shoot yourself in the foot when reading varargs.</p>
            </div>
        </section>

        <section id="concept">
            <div class="section-header">
                <div class="section-icon concept">ğŸ’¡</div>
                <h2 class="section-title">CORE CONCEPTS</h2>
            </div>
            <div class="content">
                <ul>
                    <li>Fixed parameters vs. variable arguments: the function signature contains fixed parameters; varargs follow those.</li>
                    <li>va_list: an opaque handle you use to traverse the variable arguments.</li>
                    <li>Default argument promotions: char/short â†’ int, float â†’ double â€” important when you call va_arg.</li>
                    <li>You must know the exact type you pass to va_arg â€” mismatches are undefined behavior.</li>
                </ul>
            </div>
        </section>

        <section id="mechanics">
            <div class="section-header">
                <div class="section-icon mechanics">âš™ï¸</div>
                <h2 class="section-title">HOW IT WORKS</h2>
            </div>
            <div class="content">
                <h3>The API (short)</h3>
                <ul>
                    <li>va_list ap; â€” declare a varargs traversal object.</li>
                    <li>va_start(ap, last_fixed_arg) â€” initialize ap; last_fixed_arg is the name of the last fixed parameter.</li>
                    <li>va_arg(ap, TYPE) â€” fetch the next argument as TYPE; advance ap.</li>
                    <li>va_end(ap) â€” clean up; always call it before returning.</li>
                    <li>va_copy(dest, src) â€” copy a va_list when you need to traverse more than once.</li>
                </ul>
                <p>va_list is typically implemented by the system C library and may be a pointer or a small struct â€” treat it as opaque. On some ABIs it points at a register save area and a stack area (more in the ABI section).</p>
            </div>
        </section>

        <section id="examples">
            <div class="section-header">
                <div class="section-icon examples">ğŸŒ</div>
                <h2 class="section-title">REAL EXAMPLES</h2>
            </div>
            <div class="content">
                <h3>Sum integers (safe)</h3>
                <div class="code-block" data-language="c">
                    <textarea id="code-jybi329x3" class="codemirror-code">#include <stdarg.h>\n#include <stdio.h>\n\nint sum_ints(int count, ...) {\n    va_list ap;\n    va_start(ap, count);\n    int total = 0;\n    for (int i = 0; i < count; ++i) {\n        // We expect int arguments (note: char/short promoted to int)\n        int v = va_arg(ap, int);\n        total += v;\n    }\n    va_end(ap);\n    return total;\n}\n\nint main(void) {\n    printf("sum: %d\
", sum_ints(4, 1, 2, 3, 4));\n    return 0;\n}</textarea>
                </div>
                <h3>Handling floats/doubles (promotion)</h3>
                <p>Remember: float arguments are promoted to double when passed through '...'. So when retrieving a float, use va_arg(ap, double) and cast if needed.</p>
                <div class="code-block" data-language="c">
                    <textarea id="code-b3y0ohztb" class="codemirror-code">#include <stdarg.h>\n#include <stdio.h>\n\ndouble average(int count, ...) {\n    va_list ap;\n    va_start(ap, count);\n    double sum = 0.0;\n    for (int i = 0; i < count; ++i) {\n        // floats are promoted to double when passed variadically\n        double v = va_arg(ap, double);\n        sum += v;\n    }\n    va_end(ap);\n    return count ? sum / count : 0.0;\n}\n\nint main(void) {\n    printf("avg: %f\
", average(3, 1.0f, 2.0f, 3.0f)); // 1.0f promoted to double\n    return 0;\n}</textarea>
                </div>
                <h3>A tiny printf-like parser (illustrative)</h3>
                <div class="code-block" data-language="c">
                    <textarea id="code-iqyxogkj5" class="codemirror-code">#include <stdarg.h>\n#include <stdio.h>\n\nvoid my_print(const char *fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n    for (const char *p = fmt; *p; ++p) {\n        if (*p != '%') {\n            putchar(*p);\n            continue;\n        }\n        ++p;\n        switch (*p) {\n            case 'd': {\n                int i = va_arg(ap, int);\n                printf("%d", i);\n                break;\n            }\n            case 'f': {\n                // Note: float promoted to double\n                double d = va_arg(ap, double);\n                printf("%f", d);\n                break;\n            }\n            case 's': {\n                char *s = va_arg(ap, char*);\n                printf("%s", s);\n                break;\n            }\n            default: putchar('%'); putchar(*p); break;\n        }\n    }\n    va_end(ap);\n}\n\nint main(void) {\n    my_print("num=%d name=%s pi=%f\
", 42, "Alice", 3.14159f);\n    return 0;\n}</textarea>
                </div>
            </div>
        </section>

        <section id="practice">
            <div class="section-header">
                <div class="section-icon practice">ğŸ› ï¸</div>
                <h2 class="section-title">DO THIS NOW</h2>
            </div>
            <div class="content">
                <div class="action-box">
                <ol>
                    <li>Write a variadic function that concatenates N strings and returns a heap-allocated result.</li>
                    <li>Write tests: call it with 0, 1, and many strings; verify memory is freed properly.</li>
                    <li>Try passing a float to your function and see what happens if you call va_arg with float vs double (observe the crash or garbage).</li>
                </ol>
                <p>What to look for: crashes when you request the wrong type with va_arg, incorrect values when you forget promotions or va_end.</p>
                </div>
            </div>
        </section>

        <section id="warnings">
            <div class="section-header">
                <div class="section-icon warnings">âš ï¸</div>
                <h2 class="section-title">AVOID THESE</h2>
            </div>
            <div class="content">
                <ul>
                    <li>Never pass types to va_arg that don't match what was actually passed â€” UB follows.</li>
                    <li>Don't use va_arg to detect how many arguments were passed â€” always supply a count or sentinel.</li>
                    <li>Always call va_end on each va_start; use va_copy before reusing a va_list for multiple passes.</li>
                    <li>Be careful with pointer types and lifetime: passing pointers to local stack variables can dangle.</li>
                </ul>
            </div>
        </section>

        <section id="performance">
            <div class="section-header">
                <div class="section-icon performance">ğŸš€</div>
                <h2 class="section-title">REGISTERS & ABI NOTES</h2>
            </div>
            <div class="content">
                <p>Where do the extra args go? It depends on the platform ABI. On classic 32-bit ABIs, varargs are simply pushed on the stack after the fixed args. On modern 64-bit ABIs (e.g., x86-64 System V), the implementation is more nuanced and va_list is typically a small struct that references two areas: a register save area and an overflow (stack) area.</p>
                <p>High-level x86-64 SysV summary: The ABI uses certain registers for the first integer/pointer args (RDI, RSI, RDX, RCX, R8, R9) and XMM0â€“XMM7 for floating args. When calling a function, the compiler copies those register arguments into a register save area so va_arg can fetch them consistently. Additional arguments (or arguments that don't fit in the registers) go on the stack (overflow area). The C library's va_arg implementation uses offsets into these areas to return the next value.</p>
                <p>Because va_list depends on the ABI, its concrete type varies by platform and libc. Don't assume it is a simple pointer â€” use the macros in <stdarg.h>.</p>
                <p>Final note: varargs and performance â€” reading many arguments with va_arg can be slightly slower than fixed parameters because of the indirection and possible spill/restore, but for most use cases it's negligible compared to real work like I/O or formatting.</p>
            </div>
        </section>

        <section id="test">
            <div class="section-header">
                <div class="section-icon test">ğŸ¯</div>
                <h2 class="section-title">TEST YOURSELF</h2>
            </div>
            <div class="content">
                <ol>
                    <li>What happens if you call va_arg(ap, float) when the caller passed a float literal?</li>
                    <li>Why is va_copy needed if you want to traverse arguments twice?</li>
                    <li>How does default argument promotion affect retrieving 'char' and 'double' from a va_list?</li>
                </ol>
                <p>Success criteria: you can write a variadic function that correctly retrieves ints and doubles, and you can explain promotion and ABI register/stack roles in one sentence.</p>
            </div>
        </section>

        <section id="growth">
            <div class="section-header">
                <div class="section-icon growth">ğŸ“ˆ</div>
                <h2 class="section-title">LEVEL UP</h2>
            </div>
            <div class="content">
                <ul>
                    <li>Read the platform ABI documentation (e.g., System V AMD64 ABI) to learn the exact va_list layout.</li>
                    <li>Explore compiler builtins like __builtin_va_list and how compilers implement varargs.</li>
                    <li>Consider safer variadic alternatives: use sentinel values, pass counts, or use va_list wrappers to enforce type checks (or better: use variadic macros or type-safe functions).</li>
                </ul>
            </div>
        </section>
    </main>
        <footer>
        <div class="container">
            <p>Learning journey completed! ğŸ‰</p>
            <div class="checkbox-item" style="justify-content: center; margin-top: 1rem;">
                <div class="checkbox" onclick="toggleComplete(this)"></div>
                <span>Mark this topic as mastered</span>
            </div>
        </div>
    </footer>
        <script>
        // Theme toggle
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            
            // Update button text
            updateThemeButton(newTheme);
        }

        // Update theme button text based on current theme
        function updateThemeButton(currentTheme) {
            const button = document.querySelector('.theme-toggle');
            if (currentTheme === 'dark') {
                button.innerHTML = 'â˜€ï¸ Light Mode';
            } else {
                button.innerHTML = 'ğŸŒ™ Dark Mode';
            }
        }

        // Load saved theme
        function loadTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeButton(savedTheme);
        }

        // Initialize theme on page load
        document.addEventListener('DOMContentLoaded', loadTheme);

        // Section completion
        document.querySelectorAll('.nav-item').forEach(item => {
            item.addEventListener('click', function() {
                this.classList.toggle('completed');
                const completedSections = Array.from(document.querySelectorAll('.nav-item.completed'))
                    .map(el => el.getAttribute('data-section'));
                localStorage.setItem('completed-variadic-functions-in-c--va-list--va-start--va-arg--va-end', JSON.stringify(completedSections));
            });
        });

        // Load saved progress
        const savedProgress = localStorage.getItem('completed-variadic-functions-in-c--va-list--va-start--va-arg--va-end');
        if (savedProgress) {
            const completed = JSON.parse(savedProgress);
            completed.forEach(sectionNum => {
                const navItem = document.querySelector(`[data-section="${sectionNum}"]`);
                if (navItem) navItem.classList.add('completed');
            });
        }

        // Checkbox functionality
        function toggleComplete(checkbox) {
            checkbox.classList.toggle('checked');
            if (checkbox.classList.contains('checked')) {
                checkbox.innerHTML = 'âœ“';
                localStorage.setItem('mastered-variadic-functions-in-c--va-list--va-start--va-arg--va-end', 'true');
            } else {
                checkbox.innerHTML = '';
                localStorage.setItem('mastered-variadic-functions-in-c--va-list--va-start--va-arg--va-end', 'false');
            }
        }

        // Load mastery status
        const masteryStatus = localStorage.getItem('mastered-variadic-functions-in-c--va-list--va-start--va-arg--va-end');
        if (masteryStatus === 'true') {
            const masteryCheckbox = document.querySelector('footer .checkbox');
            if (masteryCheckbox) {
                masteryCheckbox.classList.add('checked');
                masteryCheckbox.innerHTML = 'âœ“';
            }
        }

        // Smooth scrolling
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            });
        });

        // Initialize CodeMirror for all code blocks
        let initAttempts = 0;
        const maxAttempts = 50; // Max 5 seconds of retries
        
        function initializeCodeMirror() {
            initAttempts++;
            
            // Check if CodeMirror is loaded
            if (typeof CodeMirror === 'undefined') {
                if (initAttempts >= maxAttempts) {
                    console.error('Failed to load CodeMirror after', maxAttempts, 'attempts. Using fallback styling.');
                    // Fallback: Style textareas as basic code blocks
                    document.querySelectorAll('.codemirror-code').forEach(textarea => {
                        textarea.style.fontFamily = 'Monaco, Menlo, "Ubuntu Mono", monospace';
                        textarea.style.fontSize = '14px';
                        textarea.style.lineHeight = '1.5';
                        textarea.style.padding = '10px';
                        textarea.style.border = '1px solid var(--border)';
                        textarea.style.borderRadius = '4px';
                        textarea.style.background = 'var(--code-bg)';
                        textarea.style.color = 'var(--code-text)';
                        textarea.style.resize = 'none';
                        textarea.style.minHeight = '100px';
                        textarea.readOnly = true;
                    });
                    return;
                }
                console.warn('CodeMirror not loaded, retrying in 100ms... (attempt', initAttempts, '/', maxAttempts, ')');
                setTimeout(initializeCodeMirror, 100);
                return;
            }
            
            const codeTextareas = document.querySelectorAll('.codemirror-code');
            console.log('Initializing CodeMirror for', codeTextareas.length, 'code blocks');
            
            codeTextareas.forEach(textarea => {
                const codeBlock = textarea.closest('.code-block');
                const language = codeBlock.dataset.language;
                
                // Map language to CodeMirror mode
                let mode = 'text';
                switch(language) {
                    case 'c':
                    case 'cpp':
                    case 'c++':
                        mode = 'text/x-csrc';
                        break;
                    case 'javascript':
                    case 'js':
                        mode = 'javascript';
                        break;
                    case 'bash':
                    case 'shell':
                    case 'sh':
                        mode = 'shell';
                        break;
                    case 'css':
                        mode = 'css';
                        break;
                    case 'html':
                        mode = 'htmlmixed';
                        break;
                    case 'json':
                        mode = 'application/json';
                        break;
                    default:
                        mode = 'text';
                }
                
                // Use custom theme that respects CSS variables
                const cmTheme = 'default'; // We'll override with CSS
                
                try {
                    const editor = CodeMirror.fromTextArea(textarea, {
                        mode: mode,
                        theme: cmTheme,
                        lineNumbers: true,
                        readOnly: 'nocursor',  // Disable cursor and selection
                        lineWrapping: true,    // Enable line wrapping to avoid horizontal scroll
                        scrollbarStyle: 'null', // Remove scrollbars
                        viewportMargin: Infinity, // Show all content without scrolling
                        matchBrackets: false,  // Disable bracket matching highlights
                        styleActiveLine: false, // Disable active line highlighting
                        indentUnit: 4,
                        tabSize: 4
                    });
                    
                    // Store editor reference for theme switching
                    textarea.codeMirrorInstance = editor;
                    
                    // Auto-refresh editor size and ensure no scrollbars
                    setTimeout(() => {
                        editor.refresh();
                        editor.setSize(null, 'auto'); // Auto-height based on content
                    }, 100);
                    
                    console.log('CodeMirror initialized for language:', language, 'mode:', mode);
                } catch (error) {
                    console.error('Failed to initialize CodeMirror for textarea:', error);
                }
            });
        }
        
        // CodeMirror themes are handled by CSS variables, no need to update programmatically
        
        // Initialize CodeMirror when DOM and scripts are fully loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                // Wait a bit more for all scripts to load
                setTimeout(initializeCodeMirror, 200);
            });
        } else {
            // Document already loaded, wait for scripts
            setTimeout(initializeCodeMirror, 200);
        }
    </script>
</body>
</html>