<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="../../imgs/favicon.png" type="image/x-icon">
    <link rel="stylesheet" href="../../style/main.css">
    
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/darcula.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/default.min.css">
    
    <!-- CodeMirror JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/clike/clike.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/shell/shell.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/css/css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/htmlmixed/htmlmixed.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/selection/active-line.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/matchbrackets.min.js"></script>
    
    <title>Understanding File Descriptors: How Linux Connects Processes to Files - Learning Guide</title>
</head>
<body>
        <header>
        <div class="container">
            <div class="header-content">
                <div class="header-title">
                    <h1>Understanding File Descriptors: How Linux Connects Processes to Files</h1>
                    <div class="author-info">By sel-mlil</div>
                </div>
                <div class="header-nav">
                    <a href="../../" class="back-to-index">
                        Back to Index
                    </a>
                    <button class="theme-toggle" onclick="toggleTheme()">üåô Dark Mode</button>
                </div>
            </div>
        </div>
    </header>
        <nav>
        <div class="container">
            <div class="guide-nav-grid">
                <a class="guide-nav-item" href="#hook" data-section="0">üéØ The Hook</a>
                <a class="guide-nav-item" href="#layer1" data-section="1">1Ô∏è‚É£ Layer 1: File Descriptors</a>
                <a class="guide-nav-item" href="#layer2" data-section="2">2Ô∏è‚É£ Layer 2: FD Table</a>
                <a class="guide-nav-item" href="#layer3" data-section="3">3Ô∏è‚É£ Layer 3: File Struct</a>
                <a class="guide-nav-item" href="#layer4" data-section="4">4Ô∏è‚É£ Layer 4: Inode</a>
                <a class="guide-nav-item" href="#mechanics" data-section="5">‚öôÔ∏è How It Works Together</a>
                <a class="guide-nav-item" href="#examples" data-section="6">üåç Practical Implications</a>
                <a class="guide-nav-item" href="#questions" data-section="7">‚ùì Common Questions</a>
                <a class="guide-nav-item" href="#growth" data-section="8">üìà Next Steps</a>
                <a class="guide-nav-item" href="#practice" data-section="9">üõ†Ô∏è Experiment Ideas</a>
            </div>
        </div>
    </nav>
        <main class="container">
        <section id="hook">
            <div class="section-header">
                <div class="section-icon hook">üéØ</div>
                <h2 class="section-title">THE BIG PICTURE</h2>
            </div>
            <div class="content">
                <p><strong>What is this?</strong><br>When your program opens a file, reads from a socket, or writes to the terminal, you're navigating through one of the most elegant architectures in operating systems design. File descriptors are your program's gateway to the outside world, but they're just the visible tip of a sophisticated multi-layered system.</p>
                <p><strong>Why care?</strong><br>Understanding this architecture explains: (1) Why multiple processes can read the same file simultaneously, (2) How fork() affects open files, (3) Why file descriptor leaks crash your applications, (4) How redirection and piping actually work under the hood.</p>
                <p><strong>Mental model:</strong><br>Think of it like a library system: You have a <strong>library card number</strong> (file descriptor), which references an entry in the <strong>librarian's catalog</strong> (process file descriptor table), which points to detailed <strong>checkout information</strong> (file struct), which finally leads you to the actual <strong>book on the shelf</strong> (inode and physical file).</p>
            </div>
        </section>

        <section id="layer1">
            <div class="section-header">
                <div class="section-icon mechanics">1Ô∏è‚É£</div>
                <h2 class="section-title">LAYER 1: FILE DESCRIPTORS</h2>
            </div>
            <div class="content">
                <h3>Your Program's View</h3>
                <p>A file descriptor is simply a <strong>non-negative integer</strong> that your program uses to reference an open file. It's your program's handle to interact with files, sockets, pipes, or any I/O resource.</p>
                <p><strong>The standard three:</strong></p>
                <ul>
                    <li><code>0</code> = stdin (standard input)</li>
                    <li><code>1</code> = stdout (standard output)</li>
                    <li><code>2</code> = stderr (standard error)</li>
                </ul>
                <p>When you call <code>open()</code>, <code>socket()</code>, or <code>pipe()</code>, the kernel returns the <strong>lowest available file descriptor number</strong> (usually starting from 3 if the standard three are already open).</p>
                <div class="code-block" data-language="c">
                    <textarea id="code-6sn8532dw" class="codemirror-code">int fd = open("/tmp/data.txt", O_RDONLY);
// fd might be 3, 4, 5... depending on what's already open
read(fd, buffer, sizeof(buffer));
close(fd);</textarea>
                </div>
                <div class="info-box">
                <p><strong>Key insight:</strong> The file descriptor is process-specific. Your process's FD 3 and another process's FD 3 are completely independent and can refer to entirely different files.</p>
                </div>
            </div>
        </section>

        <section id="layer2">
            <div class="section-header">
                <div class="section-icon mechanics">2Ô∏è‚É£</div>
                <h2 class="section-title">LAYER 2: THE PROCESS FD TABLE</h2>
            </div>
            <div class="content">
                <h3>Your Personal Catalog</h3>
                <p>Each process maintains its own <strong>file descriptor table</strong>‚Äîessentially an array where the index is the file descriptor number, and each entry points to a <code>file</code> struct in kernel memory.</p>
                <div class="code-block" data-language="text">
                    <textarea id="code-mqkaxemcw" class="codemirror-code">Process FD Table:
[0] ‚Üí pointer to file struct (stdin)
[1] ‚Üí pointer to file struct (stdout)
[2] ‚Üí pointer to file struct (stderr)
[3] ‚Üí pointer to file struct (your opened file)
[4] ‚Üí pointer to file struct (a socket)
[5] ‚Üí NULL (closed/unused)</textarea>
                </div>
                <h3>Critical behavior during fork()</h3>
                <p>When a process forks, the child gets a <strong>copy</strong> of the parent's file descriptor table. Both parent and child have file descriptors (say, FD 3), but these point to the <strong>same file struct</strong> in kernel memory.</p>
                <div class="code-block" data-language="c">
                    <textarea id="code-9nuff6tgq" class="codemirror-code">int fd = open("shared.txt", O_RDWR);
if (fork() == 0) {
    // Child process
    write(fd, "child", 5);  // Both see each other's writes!
} else {
    // Parent process
    write(fd, "parent", 6);
}</textarea>
                </div>
                <p>This is why parent and child share the <strong>file offset</strong>‚Äîthey're using the same file struct.</p>
            </div>
        </section>

        <section id="layer3">
            <div class="section-header">
                <div class="section-icon mechanics">3Ô∏è‚É£</div>
                <h2 class="section-title">LAYER 3: THE FILE STRUCT</h2>
            </div>
            <div class="content">
                <h3>The Checkout Record</h3>
                <p>The <code>file</code> struct (also called the "open file description" in POSIX terminology) is a <strong>kernel data structure</strong> that represents an open file session. This is shared across processes if they share the file descriptor (through <code>fork()</code> or <code>dup()</code>).</p>
                <p><strong>What it contains:</strong></p>
                <ul>
                    <li><strong>File offset (position):</strong> Where the next read/write will occur</li>
                    <li><strong>Access mode:</strong> Read-only, write-only, read-write (O_RDONLY, O_WRONLY, O_RDWR)</li>
                    <li><strong>File status flags:</strong> Append mode, non-blocking, etc. (O_APPEND, O_NONBLOCK)</li>
                    <li><strong>Reference count:</strong> How many file descriptors point to this struct</li>
                    <li><strong>Pointer to inode:</strong> The actual file metadata</li>
                </ul>
                <h3>Shared vs Independent File Structs</h3>
                <p>Multiple file descriptors can point to the same file struct (via <code>dup()</code> or <code>fork()</code>), so they share the offset:</p>
                <div class="code-block" data-language="c">
                    <textarea id="code-ncocoy64s" class="codemirror-code">int fd1 = open("file.txt", O_RDONLY);
int fd2 = dup(fd1);  // fd2 shares the same file struct as fd1

read(fd1, buf, 10);  // Advances offset by 10
read(fd2, buf, 10);  // Continues from position 10, not 0!</textarea>
                </div>
                <p>But opening the same file twice creates <strong>separate file structs</strong>:</p>
                <div class="code-block" data-language="c">
                    <textarea id="code-vn72ljxpf" class="codemirror-code">int fd1 = open("file.txt", O_RDONLY);
int fd2 = open("file.txt", O_RDONLY);  // Different file struct

read(fd1, buf, 10);  // Advances fd1's offset
read(fd2, buf, 10);  // Reads from position 0, independent offset!</textarea>
                </div>
            </div>
        </section>

        <section id="layer4">
            <div class="section-header">
                <div class="section-icon mechanics">4Ô∏è‚É£</div>
                <h2 class="section-title">LAYER 4: THE INODE</h2>
            </div>
            <div class="content">
                <h3>The Book Itself</h3>
                <p>The inode (index node) is the <strong>actual file metadata</strong> stored on disk (and cached in memory). It contains everything about the file <strong>except its name and data content</strong>.</p>
                <p><strong>What it contains:</strong></p>
                <ul>
                    <li><strong>File type:</strong> Regular file, directory, symbolic link, device file, etc.</li>
                    <li><strong>Permissions:</strong> Owner, group, read/write/execute bits</li>
                    <li><strong>Ownership:</strong> User ID and group ID</li>
                    <li><strong>Timestamps:</strong> Last access, modification, status change</li>
                    <li><strong>Size:</strong> File size in bytes</li>
                    <li><strong>Link count:</strong> Number of hard links pointing to this inode</li>
                    <li><strong>Pointers to data blocks:</strong> Where the actual file content lives on disk</li>
                </ul>
                <div class="info-box">
                <p><strong>Key insight:</strong> The filename is NOT in the inode. Filenames live in directory entries that point to inodes. This is why you can have multiple filenames (hard links) pointing to the same inode.</p>
                </div>
                <div class="code-block" data-language="bash">
                    <textarea id="code-zptyvtiws" class="codemirror-code">$ ln /tmp/original.txt /tmp/link.txt
# Both filenames point to the same inode</textarea>
                </div>
                <p><strong>Shared across all opens:</strong> No matter how many processes open the same file, they all ultimately reference the <strong>same inode</strong>. This is why file permission changes are immediately visible to all processes.</p>
            </div>
        </section>

        <section id="mechanics">
            <div class="section-header">
                <div class="section-icon mechanics">‚öôÔ∏è</div>
                <h2 class="section-title">HOW IT ALL WORKS TOGETHER</h2>
            </div>
            <div class="content">
                <h3>The Complete Flow</h3>
                <p>Let's trace what happens when two processes open the same file:</p>
                <h4>Process A opens /etc/passwd:</h4>
                <div class="code-block" data-language="c">
                    <textarea id="code-2xyvpchfe" class="codemirror-code">int fd_a = open("/etc/passwd", O_RDONLY);  // Returns fd 3</textarea>
                </div>
                <ol>
                    <li>Kernel creates a <strong>file struct</strong> for this open session</li>
                    <li>Kernel locates the <strong>inode</strong> for <code>/etc/passwd</code></li>
                    <li>File struct stores: offset=0, mode=O_RDONLY, pointer to inode</li>
                    <li>Process A's FD table[3] points to this file struct</li>
                </ol>
                <h4>Process B opens /etc/passwd:</h4>
                <div class="code-block" data-language="c">
                    <textarea id="code-j17vafcu8" class="codemirror-code">int fd_b = open("/etc/passwd", O_RDONLY);  // Returns fd 3 in Process B</textarea>
                </div>
                <ol>
                    <li>Kernel creates a <strong>separate file struct</strong> (new open session)</li>
                    <li>Kernel finds the <strong>same inode</strong> for <code>/etc/passwd</code></li>
                    <li>File struct stores: offset=0, mode=O_RDONLY, pointer to same inode</li>
                    <li>Process B's FD table[3] points to its own file struct</li>
                </ol>
                <h3>The Resulting Structure</h3>
                <div class="code-block" data-language="text">
                    <textarea id="code-xdbsbadzm" class="codemirror-code">Process A FD Table          Process B FD Table
[3] ‚Üí File Struct A         [3] ‚Üí File Struct B
      offset: 0                   offset: 0
      mode: O_RDONLY              mode: O_RDONLY
      ‚Üì                           ‚Üì
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Inode ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  /etc/passwd
                  size: 2847
                  permissions: 0644
                  ‚Üí Data blocks on disk</textarea>
                </div>
                <p><strong>What this means:</strong></p>
                <ul>
                    <li>‚úÖ Each process has independent file offsets (different file structs)</li>
                    <li>‚úÖ Both see the same file size and permissions (shared inode)</li>
                    <li>‚úÖ If one process writes (and has write permission), both see the changes (shared inode data)</li>
                    <li>‚úÖ File descriptors are process-local (both use FD 3, no conflict)</li>
                </ul>
            </div>
        </section>

        <section id="examples">
            <div class="section-header">
                <div class="section-icon examples">üåç</div>
                <h2 class="section-title">PRACTICAL IMPLICATIONS</h2>
            </div>
            <div class="content">
                <h3>Why This Design Matters</h3>
                <h4>1. File Descriptor Inheritance (fork behavior)</h4>
                <div class="code-block" data-language="c">
                    <textarea id="code-4dy4d9com" class="codemirror-code">int fd = open("shared.txt", O_RDWR);
if (fork() == 0) {
    write(fd, "A", 1);
    close(fd);
} else {
    wait(NULL);
    write(fd, "B", 1);  // Writes at position 1, not 0!
    close(fd);
}
// File contains: "AB" (shared offset)</textarea>
                </div>
                <h4>2. Redirection in Shells</h4>
                <div class="code-block" data-language="bash">
                    <textarea id="code-vtie8l8pj" class="codemirror-code">$ command > output.txt</textarea>
                </div>
                <p>What happens: Shell opens <code>output.txt</code> (gets FD 3), then uses <code>dup2(3, 1)</code> to make FD 1 (stdout) point to the same file struct. Now stdout goes to the file!</p>
                <h4>3. File Descriptor Leaks</h4>
                <div class="code-block" data-language="c">
                    <textarea id="code-rjcj4p9l5" class="codemirror-code">while (true) {
    int fd = open("file.txt", O_RDONLY);
    // Forgot close(fd)!
}
// Eventually runs out of file descriptors (ulimit -n)</textarea>
                </div>
                <p>Each process has a limit (typically 1024 or higher). The FD table fills up, and <code>open()</code> fails.</p>
                <h4>4. Multiple Opens vs. Shared Descriptors</h4>
                <ul>
                    <li><strong>Multiple opens:</strong> Independent offsets, can read same file simultaneously</li>
                    <li><strong>dup()/fork():</strong> Shared offset, coordinated access (or conflicts)</li>
                </ul>
            </div>
        </section>

        <section id="questions">
            <div class="section-header">
                <div class="section-icon test">‚ùì</div>
                <h2 class="section-title">COMMON QUESTIONS</h2>
            </div>
            <div class="content">
                <h3>Q: What happens if I delete a file that's still open?</h3>
                <p>The inode remains in memory and the data blocks stay on disk until <strong>all file structs</strong> referencing it are closed. The file becomes unlinked (no directory entry), but continues to exist until the last <code>close()</code>.</p>
                <h3>Q: How do I see a process's open file descriptors?</h3>
                <div class="code-block" data-language="bash">
                    <textarea id="code-cd1g0qepe" class="codemirror-code">$ ls -l /proc/<PID>/fd
$ lsof -p <PID></textarea>
                </div>
                <h3>Q: Can two threads in the same process have different file descriptor tables?</h3>
                <p>No! Threads share the same file descriptor table. If one thread closes FD 3, it's closed for all threads.</p>
                <h3>Q: What's the difference between a file struct and an inode?</h3>
                <ul>
                    <li><strong>File struct:</strong> Represents an <em>open session</em> (offset, flags). Created by <code>open()</code>, destroyed by <code>close()</code>.</li>
                    <li><strong>Inode:</strong> Represents the <em>file itself</em> (metadata, location). Persists on disk, cached in memory.</li>
                </ul>
                <h3>Q: Why does dup2() exist if I can just assign fd1 = fd2?</h3>
                <p>That would just copy the integer! <code>dup2()</code> makes the FD table entry at position <code>fd1</code> point to the same file struct as <code>fd2</code>. It's a kernel operation, not a simple assignment.</p>
                <h3>Q: How does O_CLOEXEC work?</h3>
                <p>It sets a flag in the FD table entry (not the file struct) that tells the kernel to automatically close this descriptor when <code>exec()</code> is called. Prevents FD leaks across program execution.</p>
            </div>
        </section>

        <section id="growth">
            <div class="section-header">
                <div class="section-icon growth">üìà</div>
                <h2 class="section-title">WHERE TO GO FROM HERE</h2>
            </div>
            <div class="content">
                <p>Now that you understand the architecture, you can explore:</p>
                <ul>
                    <li><strong>Advanced file operations:</strong> <code>fcntl()</code> for fine-grained control, <code>flock()</code> for locking</li>
                    <li><strong>Memory-mapped files:</strong> <code>mmap()</code> bypasses the file struct offset mechanism</li>
                    <li><strong>Asynchronous I/O:</strong> <code>select()</code>, <code>poll()</code>, <code>epoll()</code> for monitoring multiple FDs</li>
                    <li><strong>Special file types:</strong> Device files, pipes, sockets (all use the same FD mechanism!)</li>
                    <li><strong>Filesystem internals:</strong> How inodes map to data blocks, journaling, extents</li>
                </ul>
            </div>
        </section>

        <section id="practice">
            <div class="section-header">
                <div class="section-icon practice">üõ†Ô∏è</div>
                <h2 class="section-title">EXPERIMENT IDEAS</h2>
            </div>
            <div class="content">
                <div class="action-box">
                <p><strong>Want to experiment?</strong> Try writing a program that:</p>
                <ol>
                    <li>Opens the same file twice and reads from both‚Äîobserve independent offsets</li>
                    <li>Uses <code>fork()</code> with a shared file descriptor‚Äîobserve shared offset</li>
                    <li>Uses <code>dup()</code> and sees how the offset behaves</li>
                    <li>Monitors <code>/proc/self/fd</code> to see your FDs in real-time</li>
                </ol>
                </div>
                <p><strong>Your Questions?</strong><br>This article covered the interconnected layers between your program and the filesystem, but deliberately left room for deeper exploration:</p>
                <ul>
                    <li>Want to know how inodes map to physical disk blocks?</li>
                    <li>Curious about how sockets fit into this same FD framework?</li>
                    <li>Need to understand file locking mechanisms?</li>
                    <li>Wondering about the performance implications of FD operations?</li>
                </ul>
            </div>
        </section>
    </main>
        <footer>
        <div class="container">
            <p>Learning journey completed! üéâ</p>
            <div class="checkbox-item" style="justify-content: center; margin-top: 1rem;">
                <div class="checkbox" onclick="toggleComplete(this)"></div>
                <span>Mark this topic as mastered</span>
            </div>
        </div>
    </footer>
        <script>
        // Theme toggle
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            
            // Update button text
            updateThemeButton(newTheme);
        }

        // Update theme button text based on current theme
        function updateThemeButton(currentTheme) {
            const button = document.querySelector('.theme-toggle');
            if (currentTheme === 'dark') {
                button.innerHTML = '‚òÄÔ∏è Light Mode';
            } else {
                button.innerHTML = 'üåô Dark Mode';
            }
        }

        // Load saved theme
        function loadTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeButton(savedTheme);
        }

        // Initialize theme on page load
        document.addEventListener('DOMContentLoaded', loadTheme);

        // Section completion
        document.querySelectorAll('.nav-item').forEach(item => {
            item.addEventListener('click', function() {
                this.classList.toggle('completed');
                const completedSections = Array.from(document.querySelectorAll('.nav-item.completed'))
                    .map(el => el.getAttribute('data-section'));
                localStorage.setItem('completed-understanding-file-descriptors--how-linux-connects-processes-to-files', JSON.stringify(completedSections));
            });
        });

        // Load saved progress
        const savedProgress = localStorage.getItem('completed-understanding-file-descriptors--how-linux-connects-processes-to-files');
        if (savedProgress) {
            const completed = JSON.parse(savedProgress);
            completed.forEach(sectionNum => {
                const navItem = document.querySelector(`[data-section="${sectionNum}"]`);
                if (navItem) navItem.classList.add('completed');
            });
        }

        // Checkbox functionality
        function toggleComplete(checkbox) {
            checkbox.classList.toggle('checked');
            if (checkbox.classList.contains('checked')) {
                checkbox.innerHTML = '‚úì';
                localStorage.setItem('mastered-understanding-file-descriptors--how-linux-connects-processes-to-files', 'true');
            } else {
                checkbox.innerHTML = '';
                localStorage.setItem('mastered-understanding-file-descriptors--how-linux-connects-processes-to-files', 'false');
            }
        }

        // Load mastery status
        const masteryStatus = localStorage.getItem('mastered-understanding-file-descriptors--how-linux-connects-processes-to-files');
        if (masteryStatus === 'true') {
            const masteryCheckbox = document.querySelector('footer .checkbox');
            if (masteryCheckbox) {
                masteryCheckbox.classList.add('checked');
                masteryCheckbox.innerHTML = '‚úì';
            }
        }

        // Smooth scrolling
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            });
        });

        // Initialize CodeMirror for all code blocks
        let initAttempts = 0;
        const maxAttempts = 50; // Max 5 seconds of retries
        
        function initializeCodeMirror() {
            initAttempts++;
            
            // Check if CodeMirror is loaded
            if (typeof CodeMirror === 'undefined') {
                if (initAttempts >= maxAttempts) {
                    console.error('Failed to load CodeMirror after', maxAttempts, 'attempts. Using fallback styling.');
                    // Fallback: Style textareas as basic code blocks
                    document.querySelectorAll('.codemirror-code').forEach(textarea => {
                        textarea.style.fontFamily = 'Monaco, Menlo, "Ubuntu Mono", monospace';
                        textarea.style.fontSize = '14px';
                        textarea.style.lineHeight = '1.5';
                        textarea.style.padding = '10px';
                        textarea.style.border = '1px solid var(--border)';
                        textarea.style.borderRadius = '4px';
                        textarea.style.background = 'var(--code-bg)';
                        textarea.style.color = 'var(--code-text)';
                        textarea.style.resize = 'none';
                        textarea.style.minHeight = '100px';
                        textarea.readOnly = true;
                    });
                    return;
                }
                console.warn('CodeMirror not loaded, retrying in 100ms... (attempt', initAttempts, '/', maxAttempts, ')');
                setTimeout(initializeCodeMirror, 100);
                return;
            }
            
            const codeTextareas = document.querySelectorAll('.codemirror-code');
            console.log('Initializing CodeMirror for', codeTextareas.length, 'code blocks');
            
            codeTextareas.forEach(textarea => {
                const codeBlock = textarea.closest('.code-block');
                const language = codeBlock.dataset.language;
                
                // Map language to CodeMirror mode
                let mode = 'text';
                switch(language) {
                    case 'c':
                    case 'cpp':
                    case 'c++':
                        mode = 'text/x-csrc';
                        break;
                    case 'javascript':
                    case 'js':
                        mode = 'javascript';
                        break;
                    case 'bash':
                    case 'shell':
                    case 'sh':
                        mode = 'shell';
                        break;
                    case 'css':
                        mode = 'css';
                        break;
                    case 'html':
                        mode = 'htmlmixed';
                        break;
                    case 'json':
                        mode = 'application/json';
                        break;
                    default:
                        mode = 'text';
                }
                
                // Use custom theme that respects CSS variables
                const cmTheme = 'default'; // We'll override with CSS
                
                try {
                    const editor = CodeMirror.fromTextArea(textarea, {
                        mode: mode,
                        theme: cmTheme,
                        lineNumbers: true,
                        readOnly: 'nocursor',  // Disable cursor and selection
                        lineWrapping: true,    // Enable line wrapping to avoid horizontal scroll
                        scrollbarStyle: 'null', // Remove scrollbars
                        viewportMargin: Infinity, // Show all content without scrolling
                        matchBrackets: false,  // Disable bracket matching highlights
                        styleActiveLine: false, // Disable active line highlighting
                        indentUnit: 4,
                        tabSize: 4
                    });
                    
                    // Store editor reference for theme switching
                    textarea.codeMirrorInstance = editor;
                    
                    // Auto-refresh editor size and ensure no scrollbars
                    setTimeout(() => {
                        editor.refresh();
                        editor.setSize(null, 'auto'); // Auto-height based on content
                    }, 100);
                    
                    console.log('CodeMirror initialized for language:', language, 'mode:', mode);
                } catch (error) {
                    console.error('Failed to initialize CodeMirror for textarea:', error);
                }
            });
        }
        
        // CodeMirror themes are handled by CSS variables, no need to update programmatically
        
        // Initialize CodeMirror when DOM and scripts are fully loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                // Wait a bit more for all scripts to load
                setTimeout(initializeCodeMirror, 200);
            });
        } else {
            // Document already loaded, wait for scripts
            setTimeout(initializeCodeMirror, 200);
        }
    </script>
</body>
</html>