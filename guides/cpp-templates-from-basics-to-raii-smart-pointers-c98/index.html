<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="../../imgs/favicon.png" type="image/x-icon">
    <link rel="stylesheet" href="../../style/main.css">
    
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/darcula.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/default.min.css">
    
    <!-- CodeMirror JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/clike/clike.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/shell/shell.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/css/css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/htmlmixed/htmlmixed.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/selection/active-line.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/matchbrackets.min.js"></script>
    
    <title>CPP Templates: From Basics to RAII Smart Pointers (C++98) - Learning Guide</title>
</head>
<body>
        <header>
        <div class="container">
            <div class="header-content">
                <div class="header-title">
                    <h1>CPP Templates: From Basics to RAII Smart Pointers (C++98)</h1>
                    <div class="author-info">By sel-mlil</div>
                </div>
                <div class="header-nav">
                    <a href="../../" class="back-to-index">
                        Back to Index
                    </a>
                    <button class="theme-toggle" onclick="toggleTheme()">üåô Dark Mode</button>
                </div>
            </div>
        </div>
    </header>
        <nav>
        <div class="container">
            <div class="guide-nav-grid">
                <a class="guide-nav-item" href="#hook" data-section="0">üéØ The Hook</a>
                <a class="guide-nav-item" href="#mechanics" data-section="1">‚öôÔ∏è How It Works</a>
                <a class="guide-nav-item" href="#examples" data-section="2">üåç Real Examples</a>
                <a class="guide-nav-item" href="#autoptr" data-section="3">üîß RAII Auto Pointer</a>
                <a class="guide-nav-item" href="#usecases" data-section="4">üíº Use Cases</a>
                <a class="guide-nav-item" href="#proscons" data-section="5">‚öñÔ∏è Pros & Cons</a>
                <a class="guide-nav-item" href="#warnings" data-section="6">‚ö†Ô∏è Common Pitfalls</a>
                <a class="guide-nav-item" href="#test" data-section="7">üéØ Test Yourself</a>
                <a class="guide-nav-item" href="#growth" data-section="8">üìà Level Up</a>
            </div>
        </div>
    </nav>
        <main class="container">
        <section id="hook">
            <div class="section-header">
                <div class="section-icon hook">üéØ</div>
                <h2 class="section-title">THE CONCEPT</h2>
            </div>
            <div class="content">
                <p><strong>What is it?</strong><br>Templates are C++'s compile-time code generation mechanism. They're blueprints that let the compiler automatically generate type-specific code from generic definitions. Think "code factory" - you write one template, the compiler manufactures custom versions for each type you use.</p>
                <p><strong>Why care?</strong><br>‚Ä¢ <strong>Type safety without code duplication:</strong> Write generic algorithms once, get full compiler checking for each type<br>‚Ä¢ <strong>Zero runtime overhead:</strong> All decisions happen at compile-time<br>‚Ä¢ <strong>Foundation of STL:</strong> vectors, maps, algorithms all use templates</p>
                <p><strong>Mental model:</strong><br>A cookie cutter. The template is the cutter shape; each instantiation is a unique cookie (type-specific code) the compiler bakes.</p>
            </div>
        </section>

        <section id="mechanics">
            <div class="section-header">
                <div class="section-icon mechanics">‚öôÔ∏è</div>
                <h2 class="section-title">HOW IT WORKS</h2>
            </div>
            <div class="content">
                <h3>Core mechanics</h3>
                <ol>
                    <li>You write template definition with placeholder types (<code>template&lt;typename T&gt;</code>)</li>
                    <li>Compiler sees usage like <code>MyClass&lt;int&gt;</code></li>
                    <li>Compiler generates actual code by substituting <code>int</code> for <code>T</code></li>
                    <li>Each unique instantiation creates separate code in binary</li>
                </ol>
                <h3>Key components</h3>
                <ul>
                    <li><strong>Template parameters:</strong> <code>typename T</code> or <code>class T</code> (identical in C++98)</li>
                    <li><strong>Template instantiation:</strong> Compiler-generated concrete code</li>
                    <li><strong>Specialization:</strong> Custom implementation for specific types</li>
                    <li><strong>Two-phase compilation:</strong> Template syntax checked first, full checking during instantiation</li>
                </ul>
                <h3>Governing principles</h3>
                <ul>
                    <li>Templates must be in headers (compiler needs full definition at instantiation point)</li>
                    <li>No virtual functions in template classes needed (already compile-time polymorphism)</li>
                    <li>Instantiation happens lazily - only used methods get compiled</li>
                </ul>
            </div>
        </section>

        <section id="examples">
            <div class="section-header">
                <div class="section-icon examples">üåç</div>
                <h2 class="section-title">REAL EXAMPLES</h2>
            </div>
            <div class="content">
                <h3>Function Templates</h3>
                <div class="code-block" data-language="cpp">
                    <textarea id="code-hctejxioh" class="codemirror-code">// Generic swap
template<typename T>
void swap(T& a, T& b) {
    T temp = a;
    a = b;
    b = temp;
}

// Usage
int x = 5, y = 10;
swap(x, y);  // Compiler generates swap<int>

std::string s1 = "hello", s2 = "world";
swap(s1, s2);  // Compiler generates swap<std::string></textarea>
                </div>
                <h3>Class Templates</h3>
                <div class="code-block" data-language="cpp">
                    <textarea id="code-yq3a3myfd" class="codemirror-code">template<typename T>
class Stack {
private:
    T* data;
    size_t capacity;
    size_t count;
    
public:
    Stack() : data(NULL), capacity(10), count(0) {
        data = new T[capacity];
    }
    
    ~Stack() {
        delete[] data;
    }
    
    void push(const T& value) {
        if (count == capacity) {
            resize();
        }
        data[count++] = value;
    }
    
    T pop() {
        if (count == 0) throw std::runtime_error("Empty stack");
        return data[--count];
    }
    
private:
    void resize() {
        capacity *= 2;
        T* newData = new T[capacity];
        for (size_t i = 0; i < count; ++i) {
            newData[i] = data[i];
        }
        delete[] data;
        data = newData;
    }
};

// Usage
Stack<int> intStack;
Stack<std::string> stringStack;</textarea>
                </div>
                <h3>Template Specialization</h3>
                <div class="code-block" data-language="cpp">
                    <textarea id="code-45xbnvhas" class="codemirror-code">// Generic version
template<typename T>
class Printer {
public:
    void print(const T& value) {
        std::cout << value << std::endl;
    }
};

// Specialized for bool
template<>
class Printer<bool> {
public:
    void print(const bool& value) {
        std::cout << (value ? "true" : "false") << std::endl;
    }
};</textarea>
                </div>
            </div>
        </section>

        <section id="autoptr">
            <div class="section-header">
                <div class="section-icon practice">üîß</div>
                <h2 class="section-title">COMPLETE EXAMPLE: RAII AUTO POINTER</h2>
            </div>
            <div class="content">
                <p>Building a smart pointer that automatically manages memory using RAII (Resource Acquisition Is Initialization):</p>
                <div class="code-block" data-language="cpp">
                    <textarea id="code-mkzs19zwi" class="codemirror-code">#include <iostream>
#include <stdexcept>

template<typename T>
class AutoPtr {
private:
    T* ptr;
    
    // Prevent copying (C++98 way - declare private, don't implement)
    AutoPtr(const AutoPtr&);
    AutoPtr& operator=(const AutoPtr&);
    
public:
    // Constructor
    explicit AutoPtr(T* p = NULL) : ptr(p) {}
    
    // Destructor - RAII cleanup
    ~AutoPtr() {
        delete ptr;
    }
    
    // Dereference operators
    T& operator*() const {
        if (!ptr) throw std::runtime_error("Null pointer dereference");
        return *ptr;
    }
    
    T* operator->() const {
        if (!ptr) throw std::runtime_error("Null pointer dereference");
        return ptr;
    }
    
    // Get raw pointer
    T* get() const {
        return ptr;
    }
    
    // Release ownership
    T* release() {
        T* temp = ptr;
        ptr = NULL;
        return temp;
    }
    
    // Reset with new pointer
    void reset(T* p = NULL) {
        if (ptr != p) {
            delete ptr;
            ptr = p;
        }
    }
    
    // Check if null
    bool isNull() const {
        return ptr == NULL;
    }
};</textarea>
                </div>
                <h3>Usage Example</h3>
                <div class="code-block" data-language="cpp">
                    <textarea id="code-yxrcr9s9y" class="codemirror-code">class Resource {
private:
    int id;
public:
    Resource(int i) : id(i) {
        std::cout << "Resource " << id << " created\n";
    }
    
    ~Resource() {
        std::cout << "Resource " << id << " destroyed\n";
    }
    
    void use() {
        std::cout << "Using resource " << id << "\n";
    }
};

int main() {
    // Automatic cleanup when scope ends
    {
        AutoPtr<Resource> ptr1(new Resource(1));
        ptr1->use();
        (*ptr1).use();
        
        // Transfer ownership
        AutoPtr<int> ptr2(new int(42));
        int* raw = ptr2.release();  // ptr2 no longer owns
        std::cout << "Released value: " << *raw << "\n";
        delete raw;  // Manual cleanup needed
        
        // Reset
        AutoPtr<Resource> ptr3(new Resource(3));
        ptr3.reset(new Resource(4));  // Resource 3 destroyed here
        
    } // Resource 4 destroyed automatically here
    
    return 0;
}</textarea>
                </div>
                <div class="action-box">
                <p><strong>Expected Output:</strong></p>
                <div class="code-block" data-language="text">
                    <textarea id="code-wrz7jo650" class="codemirror-code">Resource 1 created
Using resource 1
Using resource 1
Released value: 42
Resource 3 created
Resource 4 created
Resource 3 destroyed
Resource 4 destroyed
Resource 1 destroyed</textarea>
                </div>
                </div>
            </div>
        </section>

        <section id="usecases">
            <div class="section-header">
                <div class="section-icon examples">üíº</div>
                <h2 class="section-title">USE CASES</h2>
            </div>
            <div class="content">
                <h3>1. Generic Containers</h3>
                <div class="code-block" data-language="cpp">
                    <textarea id="code-ufy1bxxfy" class="codemirror-code">template<typename T>
class Vector { /* ... */ };
Vector<int> numbers;
Vector<std::string> names;</textarea>
                </div>
                <h3>2. Type-Safe Callbacks</h3>
                <div class="code-block" data-language="cpp">
                    <textarea id="code-dzutkd0z5" class="codemirror-code">template<typename Func>
void repeat(int n, Func f) {
    for (int i = 0; i < n; ++i) f();
}</textarea>
                </div>
                <h3>3. Policy-Based Design</h3>
                <div class="code-block" data-language="cpp">
                    <textarea id="code-uwvp7coy5" class="codemirror-code">template<typename T, typename Allocator = std::allocator<T> >
class Container { /* ... */ };</textarea>
                </div>
                <h3>4. Compile-Time Computation</h3>
                <div class="code-block" data-language="cpp">
                    <textarea id="code-6ozjdjs4v" class="codemirror-code">template<int N>
struct Factorial {
    enum { value = N * Factorial<N-1>::value };
};

template<>
struct Factorial<0> {
    enum { value = 1 };
};
// Factorial<5>::value == 120 at compile time</textarea>
                </div>
            </div>
        </section>

        <section id="proscons">
            <div class="section-header">
                <div class="section-icon connections">‚öñÔ∏è</div>
                <h2 class="section-title">PROS & CONS</h2>
            </div>
            <div class="content">
                <h3>Advantages</h3>
                <ul>
                    <li><strong>Zero runtime cost:</strong> All abstraction resolved at compile-time</li>
                    <li><strong>Type safety:</strong> Full compiler checking for each instantiation</li>
                    <li><strong>Code reuse:</strong> Write once, use with any compatible type</li>
                    <li><strong>Performance:</strong> Optimizer sees concrete types, can inline aggressively</li>
                    <li><strong>No virtual function overhead:</strong> Static polymorphism</li>
                </ul>
                <h3>Disadvantages</h3>
                <ul>
                    <li><strong>Code bloat:</strong> Each instantiation generates separate code</li>
                    <li><strong>Compile-time explosion:</strong> Large templates slow compilation dramatically</li>
                    <li><strong>Cryptic error messages:</strong> Template instantiation errors are notoriously hard to read</li>
                    <li><strong>Header dependency:</strong> All template code must be in headers, increases coupling</li>
                    <li><strong>Debugging difficulty:</strong> Generic code harder to step through</li>
                    <li><strong>Binary compatibility:</strong> Template changes require full recompilation</li>
                </ul>
            </div>
        </section>

        <section id="warnings">
            <div class="section-header">
                <div class="section-icon warnings">‚ö†Ô∏è</div>
                <h2 class="section-title">AVOID THESE</h2>
            </div>
            <div class="content">
                <div class="warning-box">
                <h3>1. Missing typename keyword</h3>
                <div class="code-block" data-language="cpp">
                    <textarea id="code-nbww6tmwe" class="codemirror-code">// WRONG
template<typename T>
void foo() {
    T::iterator it;  // Compiler error: "need 'typename'"
}

// CORRECT
template<typename T>
void foo() {
    typename T::iterator it;  // Tells compiler it's a type
}</textarea>
                </div>
                <h3>2. Forgetting explicit instantiation</h3>
                <div class="code-block" data-language="cpp">
                    <textarea id="code-jyjzjdvmg" class="codemirror-code">// header.h
template<typename T> class MyClass { void foo(); };

// source.cpp - WRONG
template<typename T>
void MyClass<T>::foo() { /* ... */ }
// Linker error if used in another file!

// CORRECT: Put implementation in header too</textarea>
                </div>
                <h3>3. Template + virtual confusion</h3>
                <div class="code-block" data-language="cpp">
                    <textarea id="code-916lm029u" class="codemirror-code">// WRONG THINKING
template<typename T>
class Base {
    virtual void process(T value) = 0;  // Templates already provide polymorphism!
};</textarea>
                </div>
                <h3>4. Circular dependencies</h3>
                <div class="code-block" data-language="cpp">
                    <textarea id="code-h5pta0gr6" class="codemirror-code">// Don't make templates depend on each other's instantiations
template<typename T> class A {
    B<T> b;  // Fine
};

template<typename T> class B {
    A<B<T> > a;  // Infinite instantiation!
};</textarea>
                </div>
                </div>
            </div>
        </section>

        <section id="test">
            <div class="section-header">
                <div class="section-icon test">üéØ</div>
                <h2 class="section-title">TEST YOURSELF</h2>
            </div>
            <div class="content">
                <ol>
                    <li>What happens at compile-time vs runtime with templates?</li>
                    <li>Why can't you put template implementation in .cpp files?</li>
                    <li>Modify AutoPtr to support arrays (AutoPtr&lt;T[]&gt;)</li>
                    <li>Implement a template min() function that works with any comparable type</li>
                    <li>Create a template Pair&lt;T1, T2&gt; class with first/second members</li>
                </ol>
            </div>
        </section>

        <section id="growth">
            <div class="section-header">
                <div class="section-icon growth">üìà</div>
                <h2 class="section-title">LEVEL UP</h2>
            </div>
            <div class="content">
                <ul>
                    <li><strong>This week:</strong> Implement a generic LinkedList template, study STL source code (vector, list implementations), practice template specialization with different types</li>
                    <li><strong>This month:</strong> Learn template metaprogramming basics (compile-time computation), study Boost libraries' template techniques, implement policy-based design pattern</li>
                    <li><strong>Long term:</strong> Master C++11/14/17 template improvements (variadic templates, SFINAE, concepts), study Modern C++ Design by Alexandrescu, contribute to template-heavy open source projects</li>
                </ul>
            </div>
        </section>
    </main>
        <footer>
        <div class="container">
            <p>Learning journey completed! üéâ</p>
            <div class="checkbox-item" style="justify-content: center; margin-top: 1rem;">
                <div class="checkbox" onclick="toggleComplete(this)"></div>
                <span>Mark this topic as mastered</span>
            </div>
        </div>
    </footer>
        <script>
        // Theme toggle
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            
            // Update button text
            updateThemeButton(newTheme);
        }

        // Update theme button text based on current theme
        function updateThemeButton(currentTheme) {
            const button = document.querySelector('.theme-toggle');
            if (currentTheme === 'dark') {
                button.innerHTML = '‚òÄÔ∏è Light Mode';
            } else {
                button.innerHTML = 'üåô Dark Mode';
            }
        }

        // Load saved theme
        function loadTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeButton(savedTheme);
        }

        // Initialize theme on page load
        document.addEventListener('DOMContentLoaded', loadTheme);

        // Section completion
        document.querySelectorAll('.nav-item').forEach(item => {
            item.addEventListener('click', function() {
                this.classList.toggle('completed');
                const completedSections = Array.from(document.querySelectorAll('.nav-item.completed'))
                    .map(el => el.getAttribute('data-section'));
                localStorage.setItem('completed-cpp-templates--from-basics-to-raii-smart-pointers--c--98-', JSON.stringify(completedSections));
            });
        });

        // Load saved progress
        const savedProgress = localStorage.getItem('completed-cpp-templates--from-basics-to-raii-smart-pointers--c--98-');
        if (savedProgress) {
            const completed = JSON.parse(savedProgress);
            completed.forEach(sectionNum => {
                const navItem = document.querySelector(`[data-section="${sectionNum}"]`);
                if (navItem) navItem.classList.add('completed');
            });
        }

        // Checkbox functionality
        function toggleComplete(checkbox) {
            checkbox.classList.toggle('checked');
            if (checkbox.classList.contains('checked')) {
                checkbox.innerHTML = '‚úì';
                localStorage.setItem('mastered-cpp-templates--from-basics-to-raii-smart-pointers--c--98-', 'true');
            } else {
                checkbox.innerHTML = '';
                localStorage.setItem('mastered-cpp-templates--from-basics-to-raii-smart-pointers--c--98-', 'false');
            }
        }

        // Load mastery status
        const masteryStatus = localStorage.getItem('mastered-cpp-templates--from-basics-to-raii-smart-pointers--c--98-');
        if (masteryStatus === 'true') {
            const masteryCheckbox = document.querySelector('footer .checkbox');
            if (masteryCheckbox) {
                masteryCheckbox.classList.add('checked');
                masteryCheckbox.innerHTML = '‚úì';
            }
        }

        // Smooth scrolling
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            });
        });

        // Initialize CodeMirror for all code blocks
        let initAttempts = 0;
        const maxAttempts = 50; // Max 5 seconds of retries
        
        function initializeCodeMirror() {
            initAttempts++;
            
            // Check if CodeMirror is loaded
            if (typeof CodeMirror === 'undefined') {
                if (initAttempts >= maxAttempts) {
                    console.error('Failed to load CodeMirror after', maxAttempts, 'attempts. Using fallback styling.');
                    // Fallback: Style textareas as basic code blocks
                    document.querySelectorAll('.codemirror-code').forEach(textarea => {
                        textarea.style.fontFamily = 'Monaco, Menlo, "Ubuntu Mono", monospace';
                        textarea.style.fontSize = '14px';
                        textarea.style.lineHeight = '1.5';
                        textarea.style.padding = '10px';
                        textarea.style.border = '1px solid var(--border)';
                        textarea.style.borderRadius = '4px';
                        textarea.style.background = 'var(--code-bg)';
                        textarea.style.color = 'var(--code-text)';
                        textarea.style.resize = 'none';
                        textarea.style.minHeight = '100px';
                        textarea.readOnly = true;
                    });
                    return;
                }
                console.warn('CodeMirror not loaded, retrying in 100ms... (attempt', initAttempts, '/', maxAttempts, ')');
                setTimeout(initializeCodeMirror, 100);
                return;
            }
            
            const codeTextareas = document.querySelectorAll('.codemirror-code');
            console.log('Initializing CodeMirror for', codeTextareas.length, 'code blocks');
            
            codeTextareas.forEach(textarea => {
                const codeBlock = textarea.closest('.code-block');
                const language = codeBlock.dataset.language;
                
                // Map language to CodeMirror mode
                let mode = 'text';
                switch(language) {
                    case 'c':
                    case 'cpp':
                    case 'c++':
                        mode = 'text/x-csrc';
                        break;
                    case 'javascript':
                    case 'js':
                        mode = 'javascript';
                        break;
                    case 'bash':
                    case 'shell':
                    case 'sh':
                        mode = 'shell';
                        break;
                    case 'css':
                        mode = 'css';
                        break;
                    case 'html':
                        mode = 'htmlmixed';
                        break;
                    case 'json':
                        mode = 'application/json';
                        break;
                    default:
                        mode = 'text';
                }
                
                // Use custom theme that respects CSS variables
                const cmTheme = 'default'; // We'll override with CSS
                
                try {
                    const editor = CodeMirror.fromTextArea(textarea, {
                        mode: mode,
                        theme: cmTheme,
                        lineNumbers: true,
                        readOnly: 'nocursor',  // Disable cursor and selection
                        lineWrapping: true,    // Enable line wrapping to avoid horizontal scroll
                        scrollbarStyle: 'null', // Remove scrollbars
                        viewportMargin: Infinity, // Show all content without scrolling
                        matchBrackets: false,  // Disable bracket matching highlights
                        styleActiveLine: false, // Disable active line highlighting
                        indentUnit: 4,
                        tabSize: 4
                    });
                    
                    // Store editor reference for theme switching
                    textarea.codeMirrorInstance = editor;
                    
                    // Auto-refresh editor size and ensure no scrollbars
                    setTimeout(() => {
                        editor.refresh();
                        editor.setSize(null, 'auto'); // Auto-height based on content
                    }, 100);
                    
                    console.log('CodeMirror initialized for language:', language, 'mode:', mode);
                } catch (error) {
                    console.error('Failed to initialize CodeMirror for textarea:', error);
                }
            });
        }
        
        // CodeMirror themes are handled by CSS variables, no need to update programmatically
        
        // Initialize CodeMirror when DOM and scripts are fully loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                // Wait a bit more for all scripts to load
                setTimeout(initializeCodeMirror, 200);
            });
        } else {
            // Document already loaded, wait for scripts
            setTimeout(initializeCodeMirror, 200);
        }
    </script>
</body>
</html>