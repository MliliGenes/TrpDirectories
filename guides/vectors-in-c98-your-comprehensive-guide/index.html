<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="../../imgs/favicon.png" type="image/x-icon">
    <link rel="stylesheet" href="../../style/main.css">
    
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/darcula.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/default.min.css">
    
    <!-- CodeMirror JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/clike/clike.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/shell/shell.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/css/css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/htmlmixed/htmlmixed.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/selection/active-line.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/matchbrackets.min.js"></script>
    
    <title>Vectors in C++98: Your Comprehensive Guide - Learning Guide</title>
</head>
<body>
        <header>
        <div class="container">
            <div class="header-content">
                <div class="header-title">
                    <h1>Vectors in C++98: Your Comprehensive Guide</h1>
                    <div class="author-info">By sel-mlil</div>
                </div>
                <div class="header-nav">
                    <a href="../../" class="back-to-index">
                        Back to Index
                    </a>
                    <button class="theme-toggle" onclick="toggleTheme()">üåô Dark Mode</button>
                </div>
            </div>
        </div>
    </header>
        <nav>
        <div class="container">
            <div class="guide-nav-grid">
                <a class="guide-nav-item" href="#hook" data-section="0">üéØ The Hook</a>
                <a class="guide-nav-item" href="#concept" data-section="1">üí° Core Concepts</a>
                <a class="guide-nav-item" href="#mechanics" data-section="2">‚öôÔ∏è How It Works</a>
                <a class="guide-nav-item" href="#examples" data-section="3">üåç Real Examples</a>
                <a class="guide-nav-item" href="#practice" data-section="4">üõ†Ô∏è Hands-On Practice</a>
                <a class="guide-nav-item" href="#bestpractices" data-section="5">‚ú® Best Practices</a>
                <a class="guide-nav-item" href="#warnings" data-section="6">‚ö†Ô∏è Common Pitfalls</a>
                <a class="guide-nav-item" href="#advanced" data-section="7">üéì Advanced Topics</a>
                <a class="guide-nav-item" href="#test" data-section="8">üéØ Test Yourself</a>
                <a class="guide-nav-item" href="#growth" data-section="9">üìà Next Steps</a>
            </div>
        </div>
    </nav>
        <main class="container">
        <section id="hook">
            <div class="section-header">
                <div class="section-icon hook">üéØ</div>
                <h2 class="section-title">THE HOOK</h2>
            </div>
            <div class="content">
                <p><strong>What is this?</strong><br>A <code>std::vector</code> in C++98 is a sequence container that encapsulates dynamic size arrays. It allows you to store elements of a single type in a contiguous block of memory, similar to a traditional C-style array, but with the added flexibility of automatically managing its own memory and resizing when needed.</p>
                <p><strong>Why care?</strong><br>Vectors are fundamental in C++ programming. They provide efficient random access, dynamic resizing, and a convenient interface for managing collections of data. Understanding <code>std::vector</code> is crucial for writing robust, efficient, and modern (even C++98 modern!) C++ applications, making it a cornerstone of the Standard Template Library (STL).</p>
                <p><strong>Mental model:</strong><br>Imagine a <strong>magical, infinitely expanding bookshelf</strong>. When you add a book, the shelf automatically grows to accommodate it. If you remove books, it shrinks (conceptually). You can always reach any book directly by its position (index), and you don't have to worry about running out of space or manually building new shelves when your collection expands.</p>
            </div>
        </section>

        <section id="concept">
            <div class="section-header">
                <div class="section-icon concept">üí°</div>
                <h2 class="section-title">CORE CONCEPTS</h2>
            </div>
            <div class="content">
                <h3>Dynamic Arrays</h3>
                <p><code>std::vector</code> provides the functionality of a <strong>dynamic array</strong>. Unlike static arrays whose size is fixed at compile time, vectors can grow or shrink in size during runtime. This is achieved by allocating and deallocating memory as needed.</p>
                <h3>Contiguous Memory</h3>
                <p>Elements in a <code>std::vector</code> are stored <strong>contiguously in memory</strong>. This means that if you have a vector of integers, <code>v</code>, then <code>v[0]</code>, <code>v[1]</code>, <code>v[2]</code>... are stored one after another in a single block of memory. This property is crucial for efficient random access (constant time $O(1)$) and compatibility with C-style arrays/APIs.</p>
                <h3>Automatic Memory Management</h3>
                <p>You don't manually call <code>new</code> or <code>delete</code> for individual elements or the entire underlying array. <code>std::vector</code> handles all memory allocation and deallocation. When a vector goes out of scope, its destructor automatically frees the memory it occupied.</p>
                <h3>Capacity vs. Size</h3>
                <p>This is a key distinction:<br><strong>Size:</strong> The number of elements currently stored in the vector (<code>size()</code>).<br><strong>Capacity:</strong> The total number of elements the vector can hold before it needs to reallocate more memory (<code>capacity()</code>). The capacity is always greater than or equal to the size. When <code>size()</code> reaches <code>capacity()</code>, the vector reallocates, usually doubling its capacity, and copies existing elements to the new memory location. This reallocation is an expensive operation.</p>
            </div>
        </section>

        <section id="mechanics">
            <div class="section-header">
                <div class="section-icon mechanics">‚öôÔ∏è</div>
                <h2 class="section-title">HOW IT WORKS</h2>
            </div>
            <div class="content">
                <h3>Core mechanics</h3>
                <ul>
                    <li><strong>Allocation:</strong> When a <code>std::vector</code> is created or needs to grow, it allocates a block of contiguous memory on the heap using an allocator (by default, <code>std::allocator</code>). This memory is large enough to hold <code>capacity()</code> elements.</li>
                    <li><strong>Element Construction:</strong> When elements are added (e.g., via <code>push_back</code>), they are constructed directly into the allocated memory using placement new (conceptually, though details are abstracted).</li>
                    <li><strong>Reallocation:</strong> If <code>push_back</code> is called and <code>size() == capacity()</code>, the vector performs a reallocation: a larger block of memory is allocated (typically 1.5x or 2x the current capacity), existing elements are moved (copy-constructed) to the new memory, the old memory is deallocated, and the internal pointer is updated.</li>
                    <li><strong>Element Destruction:</strong> When elements are removed (e.g., via <code>pop_back</code>, <code>erase</code>) or the vector is destroyed, their destructors are called.</li>
                    <li><strong>Deallocation:</strong> When the vector's destructor is called, the entire block of memory it occupied is deallocated. No manual <code>delete</code> is required for individual elements or the underlying array.</li>
                </ul>
                <h3>Cleaning Cycles and Memory Management</h3>
                <p>In C++98, <code>std::vector</code> handles its own memory management automatically. There isn't a 'cleaning cycle' you explicitly trigger. The cycle of allocation, construction, destruction, and deallocation happens implicitly:<br><br>1. <strong>Construction:</strong> When <code>std::vector</code> is instantiated, it may allocate memory if an initial size or capacity is specified. Elements are default-constructed or copy-constructed.<br>2. <strong>Adding Elements:</strong> <code>push_back</code> constructs a new element at the end. If capacity is exceeded, a reallocation occurs (new memory, copy existing, delete old).<br>3. <strong>Removing Elements:</strong> <code>pop_back</code> destructs the last element. <code>erase</code> destructs a range of elements and shifts subsequent elements. <code>clear</code> destructs all elements but often keeps the allocated memory (capacity remains).<br>4. <strong>Destruction:</strong> When the <code>std::vector</code> object itself goes out of scope, its destructor is called. This destructor iterates through all remaining elements, calls their destructors, and then deallocates the entire contiguous memory block that held them. This is the primary 'cleaning cycle' for the vector's owned resources.</p>
            </div>
        </section>

        <section id="examples">
            <div class="section-header">
                <div class="section-icon examples">üåç</div>
                <h2 class="section-title">REAL EXAMPLES</h2>
            </div>
            <div class="content">
                <h3>Basic Initialization and Access</h3>
                <div class="code-block" data-language="cpp">
                    <textarea id="code-oj0t5ol3g" class="codemirror-code">#include <vector>
#include <iostream>

int main() {
    // Create an empty vector of integers
    std::vector<int> numbers;
    std::cout << "Initial size: " << numbers.size() << "\n";

    // Add elements using push_back
    numbers.push_back(10);
    numbers.push_back(20);
    numbers.push_back(30);
    std::cout << "Size after pushes: " << numbers.size() << "\n";

    // Access elements using operator[]
    std::cout << "First element: " << numbers[0] << "\n";
    std::cout << "Second element: " << numbers.at(1) << " (bounds checked)\n";

    // Modify an element
    numbers[0] = 5;
    std::cout << "Modified first element: " << numbers[0] << "\n";

    // Iterate through elements (C++98 style)
    for (std::vector<int>::size_type i = 0; i < numbers.size(); ++i) {
        std::cout << numbers[i] << " ";
    }
    std::cout << "\n";

    return 0;
}</textarea>
                </div>
                <h3>Iterators and Manipulation</h3>
                <div class="code-block" data-language="cpp">
                    <textarea id="code-bc98ydyp9" class="codemirror-code">#include <vector>
#include <iostream>
#include <algorithm> // For std::find

int main() {
    std::vector<std::string> words;
    words.push_back("apple");
    words.push_back("banana");
    words.push_back("cherry");
    words.push_back("date");

    // Iterate using iterators
    std::cout << "Elements using iterators: ";
    for (std::vector<std::string>::iterator it = words.begin(); it != words.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << "\n";

    // Inserting an element
    words.insert(words.begin() + 1, "apricot"); // Insert at second position
    std::cout << "After insert: ";
    for (std::vector<std::string>::iterator it = words.begin(); it != words.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << "\n";

    // Erasing an element
    words.erase(words.begin() + 2); // Erase 'banana'
    std::cout << "After erase: ";
    for (std::vector<std::string>::iterator it = words.begin(); it != words.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << "\n";

    // Finding an element
    std::vector<std::string>::iterator it_find = std::find(words.begin(), words.end(), "cherry");
    if (it_find != words.end()) {
        std::cout << "'cherry' found at index: " << (it_find - words.begin()) << "\n";
    } else {
        std::cout << "'cherry' not found.\n";
    }

    // Removing the last element
    words.pop_back();
    std::cout << "After pop_back: ";
    for (std::vector<std::string>::iterator it = words.begin(); it != words.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << "\n";

    // Clearing the vector
    words.clear();
    std::cout << "Size after clear: " << words.size() << "\n";
    std::cout << "Capacity after clear (may still hold memory): " << words.capacity() << "\n";

    return 0;
}</textarea>
                </div>
                <h3>Capacity Management</h3>
                <div class="code-block" data-language="cpp">
                    <textarea id="code-yimtehcpa" class="codemirror-code">#include <vector>
#include <iostream>

int main() {
    std::vector<int> data;

    std::cout << "Initial capacity: " << data.capacity() << "\n";

    // Reserve space to avoid reallocations
    data.reserve(10);
    std::cout << "Capacity after reserve(10): " << data.capacity() << "\n";

    for (int i = 0; i < 5; ++i) {
        data.push_back(i);
        std::cout << "Pushed " << i << ", size: " << data.size() << ", capacity: " << data.capacity() << "\n";
    }

    // 'Shrink to fit' (C++11, but can be simulated in C++98)
    std::vector<int>(data).swap(data); // C++98 idiom to shrink capacity to size
    std::cout << "Capacity after shrink-to-fit: " << data.capacity() << "\n";

    return 0;
}</textarea>
                </div>
            </div>
        </section>

        <section id="practice">
            <div class="section-header">
                <div class="section-icon practice">üõ†Ô∏è</div>
                <h2 class="section-title">DO THIS NOW</h2>
            </div>
            <div class="content">
                <div class="action-box">
                <ol>
                    <li><strong>Create a vector of strings:</strong> Declare a <code>std::vector&lt;std::string&gt;</code>.</li>
                    <li><strong>Add names:</strong> Use <code>push_back()</code> to add 5-7 names (e.g., 'Alice', 'Bob') to your vector.</li>
                    <li><strong>Print with loop:</strong> Iterate through the vector using a <code>for</code> loop and <code>operator[]</code> to print each name.</li>
                    <li><strong>Insert a name:</strong> Use <code>insert()</code> to add a new name at the second position in your vector.</li>
                    <li><strong>Remove a name:</strong> Use <code>erase()</code> to remove one of the names you added.</li>
                    <li><strong>Print again:</strong> Iterate and print the modified vector.</li>
                    <li><strong>Check capacity:</strong> Print the <code>size()</code> and <code>capacity()</code> of your vector before and after adding/removing elements. Observe how <code>capacity</code> changes.</li>
                </ol>
                <p><strong>What to look for:</strong> Observe how the vector's `size` and `capacity` change dynamically. Notice the effect of `insert` and `erase` on element positions.<br><strong>Quick win:</strong> You'll gain immediate familiarity with the most common `std::vector` operations and its dynamic nature.</p>
                </div>
            </div>
        </section>

        <section id="bestpractices">
            <div class="section-header">
                <div class="section-icon bestpractices">‚ú®</div>
                <h2 class="section-title">BEST PRACTICES</h2>
            </div>
            <div class="content">
                <ul>
                    <li><strong>Prefer <code>std::vector</code> over raw arrays:</strong> It handles memory management automatically, reducing the risk of memory leaks and buffer overflows.</li>
                    <li><strong>Use <code>reserve()</code> to pre-allocate:</strong> If you know the approximate number of elements beforehand, use <code>reserve()</code> to pre-allocate memory. This minimizes costly reallocations and improves performance.</li>
                    <li><strong>Pass by const reference:</strong> When passing vectors to functions, pass them by <code>const std::vector&lt;T&gt;&amp;</code> to avoid unnecessary copying.</li>
                    <li><strong>Use iterators for insertion/erasure:</strong> While <code>operator[]</code> is great for random access, <code>insert()</code> and <code>erase()</code> operations typically return new iterators. Be mindful that iterators can be invalidated by modifications that cause reallocations or element shifts.</li>
                    <li><strong><code>shrink_to_fit</code> (C++11) / Copy-Swap Idiom (C++98) for memory optimization:</strong> If a vector has a large capacity but a small size, you can reduce its memory footprint. In C++98, use <code>std::vector&lt;T&gt;(my_vector).swap(my_vector);</code>.</li>
                    <li><strong>Avoid storing pointers without ownership:</strong> If a vector stores raw pointers, you are responsible for managing the memory those pointers point to. Consider smart pointers if available (not standard in C++98) or custom allocators.</li>
                    <li><strong>Favor <code>push_back</code> over <code>insert</code> at arbitrary positions:</strong> <code>insert</code> (and <code>erase</code>) in the middle of a vector is an $O(N)$ operation because it requires shifting all subsequent elements. <code>push_back</code> is amortized $O(1)$.</li>
                </ul>
            </div>
        </section>

        <section id="warnings">
            <div class="section-header">
                <div class="section-icon warnings">‚ö†Ô∏è</div>
                <h2 class="section-title">AVOID THESE</h2>
            </div>
            <div class="content">
                <div class="warning-box">
                <ul>
                    <li><strong>Accessing out-of-bounds elements (e.g., <code>vec[vec.size()]</code>)</strong> ‚Üí Use <code>at()</code> for bounds-checked access, which throws <code>std::out_of_range</code> on error. Otherwise, <code>operator[]</code> gives undefined behavior.</li>
                    <li><strong>Iterator invalidation after modification</strong> ‚Üí Any operation that changes the vector's size or capacity (e.g., <code>push_back</code> if reallocation occurs, <code>insert</code>, <code>erase</code>, <code>clear</code>) can invalidate iterators, pointers, and references to elements. Always re-obtain iterators after such operations.</li>
                    <li><strong>Excessive reallocations</strong> ‚Üí Repeatedly adding elements one by one to a vector without <code>reserve()</code> can lead to many costly reallocations. This can severely impact performance. Use <code>reserve()</code> if possible.</li>
                    <li><strong>Storing non-copyable/non-assignable objects (C++98 limitations)</strong> ‚Üí In C++98, elements stored in a <code>std::vector</code> must be copy-constructible and assignable because reallocations involve copying. If your objects cannot be copied, <code>std::vector</code> will not work (use <code>std::list</code> or store pointers).</li>
                    <li><strong>Using <code>clear()</code> to release memory</strong> ‚Üí <code>clear()</code> destroys elements but does not guarantee the release of allocated memory (capacity remains). To force memory release in C++98, use the copy-swap idiom: <code>std::vector&lt;T&gt;(my_vector).swap(my_vector);</code> (or <code>my_vector.swap(std::vector&lt;T&gt;());</code> to clear and shrink an empty vector).</li>
                </ul>
                </div>
            </div>
        </section>

        <section id="advanced">
            <div class="section-header">
                <div class="section-icon advanced">üéì</div>
                <h2 class="section-title">ADVANCED TOPICS</h2>
            </div>
            <div class="content">
                <h3>Custom Allocators</h3>
                <p>For specialized memory management needs (e.g., using a custom memory pool, handling aligned memory), you can provide a custom allocator to <code>std::vector</code>. This is a more advanced topic and typically not needed for everyday use but offers fine-grained control over memory allocation strategies.</p>
                <div class="code-block" data-language="cpp">
                    <textarea id="code-kb13er6ys" class="codemirror-code">#include <vector>
#include <iostream>
#include <memory> // For std::allocator (default)

// A very simple custom allocator example (for demonstration, not production)
template <typename T>
class MyAllocator : public std::allocator<T> {
public:
    typedef T value_type;

    MyAllocator() throw() {}
    template <typename U> MyAllocator(const MyAllocator<U>&) throw() {}

    T* allocate(size_t n, const void* hint = 0) {
        std::cout << "Allocating " << n * sizeof(T) << " bytes using MyAllocator\n";
        return std::allocator<T>::allocate(n, hint);
    }

    void deallocate(T* p, size_t n) {
        std::cout << "Deallocating " << n * sizeof(T) << " bytes using MyAllocator\n";
        std::allocator<T>::deallocate(p, n);
    }
};

int main() {
    std::vector<int, MyAllocator<int> > vec_custom_alloc;
    vec_custom_alloc.push_back(1);
    vec_custom_alloc.push_back(2);
    vec_custom_alloc.push_back(3);
    return 0;
}</textarea>
                </div>
                <h3>Exceptions and Strong Exception Guarantee</h3>
                <p>Operations like `push_back` (especially when reallocation occurs) or `insert` can throw exceptions (e.g., `std::bad_alloc` if memory cannot be allocated, or if element copy-construction throws). `std::vector` generally provides a *strong exception guarantee* for its operations: if an exception is thrown, the vector remains in a valid, unchanged state (or its previous state before the failed operation). The elements of a vector must have a non-throwing copy constructor for the strong guarantee to hold during reallocation in C++98.</p>
                <h3>`data()` member function (C++03)</h3>
                <p>While `data()` is officially C++11, in C++03 and often in C++98 implementations, you could rely on `&my_vector[0]` to get a pointer to the underlying array, leveraging the contiguous memory guarantee. Be aware of its absence in strict C++98 standards, but its practical prevalence. This is useful for interfacing with C APIs.</p>
                <div class="code-block" data-language="cpp">
                    <textarea id="code-1g3dfm8ub" class="codemirror-code">#include <vector>
#include <iostream>

// Function taking a C-style array
void print_c_array(const int* arr, size_t size) {
    for (size_t i = 0; i < size; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << "\n";
}

int main() {
    std::vector<int> numbers;
    numbers.push_back(10);
    numbers.push_back(20);
    numbers.push_back(30);

    // Get a pointer to the underlying array (C++98 common practice)
    // Note: C++11 introduced numbers.data() for this.
    if (!numbers.empty()) {
        int* raw_ptr = &numbers[0];
        print_c_array(raw_ptr, numbers.size());
    }

    return 0;
}</textarea>
                </div>
            </div>
        </section>

        <section id="connections">
            <div class="section-header">
                <div class="section-icon connections">üîó</div>
                <h2 class="section-title">CONNECTIONS</h2>
            </div>
            <div class="content">
                <ul>
                    <li><strong>Prerequisites:</strong> Basic understanding of C++ syntax, classes, templates, memory (heap vs. stack), and pointers. Familiarity with the Standard Template Library (STL) is beneficial.</li>
                    <li><strong>Related concepts:</strong> Other STL containers (e.g., <code>std::list</code>, <code>std::deque</code>, <code>std::map</code>), iterators, algorithms (<code>std::sort</code>, <code>std::find</code>), custom allocators, move semantics (not strictly C++98, but conceptually related to efficient data movement).</li>
                    <li><strong>Next steps:</strong> Explore other STL containers to understand their trade-offs (e.g., <code>std::list</code> for efficient insertions/deletions anywhere, <code>std::deque</code> for fast front/back operations). Dive into STL algorithms and how they work with iterators. Consider the differences and improvements in <code>std::vector</code> in C++11 and later standards.</li>
                </ul>
            </div>
        </section>

        <section id="test">
            <div class="section-header">
                <div class="section-icon test">üéØ</div>
                <h2 class="section-title">TEST YOURSELF</h2>
            </div>
            <div class="content">
                <ol>
                    <li>What is the key difference between <code>size()</code> and <code>capacity()</code> of a <code>std::vector</code>?</li>
                    <li>Describe the steps <code>std::vector</code> takes when <code>push_back()</code> causes a reallocation.</li>
                    <li>When would you use <code>reserve()</code>? Provide a simple code example.</li>
                    <li>Explain what iterator invalidation means for a <code>std::vector</code> and give an example of an operation that causes it.</li>
                    <li>How would you 'shrink-to-fit' a <code>std::vector</code> in C++98 to release unused capacity?</li>
                </ol>
                <p><strong>Success criteria:</strong> You can accurately answer all questions, demonstrating a solid grasp of vector fundamentals, performance implications, and C++98 specific idioms.<br><strong>Review triggers:</strong> If you struggle with questions about reallocation performance, iterator invalidation, or C++98 memory management, revisit those sections.</p>
            </div>
        </section>

        <section id="growth">
            <div class="section-header">
                <div class="section-icon growth">üìà</div>
                <h2 class="section-title">LEVEL UP</h2>
            </div>
            <div class="content">
                <ul>
                    <li><strong>This week:</strong> Implement a simple custom data structure (e.g., a dynamic array) from scratch, mimicking <code>std::vector</code>'s <code>push_back</code> and <code>pop_back</code> functionality, including reallocation logic. This will solidify your understanding of its underlying mechanics.</li>
                    <li><strong>This month:</strong> Research and compare <code>std::vector</code> with <code>std::list</code> and <code>std::deque</code>. Implement a small project where you decide which container is best suited for different parts of the application based on access patterns and modification needs.</li>
                    <li><strong>Long term:</strong> Explore the evolution of <code>std::vector</code> in C++11 and later standards (e.g., <code>emplace_back</code>, move semantics, <code>data()</code>). Understand how these changes improve efficiency and expressiveness. Experiment with custom allocators for specific performance challenges.</li>
                </ul>
            </div>
        </section>
    </main>
        <footer>
        <div class="container">
            <p>Learning journey completed! üéâ</p>
            <div class="checkbox-item" style="justify-content: center; margin-top: 1rem;">
                <div class="checkbox" onclick="toggleComplete(this)"></div>
                <span>Mark this topic as mastered</span>
            </div>
        </div>
    </footer>
        <script>
        // Theme toggle
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            
            // Update button text
            updateThemeButton(newTheme);
        }

        // Update theme button text based on current theme
        function updateThemeButton(currentTheme) {
            const button = document.querySelector('.theme-toggle');
            if (currentTheme === 'dark') {
                button.innerHTML = '‚òÄÔ∏è Light Mode';
            } else {
                button.innerHTML = 'üåô Dark Mode';
            }
        }

        // Load saved theme
        function loadTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeButton(savedTheme);
        }

        // Initialize theme on page load
        document.addEventListener('DOMContentLoaded', loadTheme);

        // Section completion
        document.querySelectorAll('.nav-item').forEach(item => {
            item.addEventListener('click', function() {
                this.classList.toggle('completed');
                const completedSections = Array.from(document.querySelectorAll('.nav-item.completed'))
                    .map(el => el.getAttribute('data-section'));
                localStorage.setItem('completed-vectors-in-c--98--your-comprehensive-guide', JSON.stringify(completedSections));
            });
        });

        // Load saved progress
        const savedProgress = localStorage.getItem('completed-vectors-in-c--98--your-comprehensive-guide');
        if (savedProgress) {
            const completed = JSON.parse(savedProgress);
            completed.forEach(sectionNum => {
                const navItem = document.querySelector(`[data-section="${sectionNum}"]`);
                if (navItem) navItem.classList.add('completed');
            });
        }

        // Checkbox functionality
        function toggleComplete(checkbox) {
            checkbox.classList.toggle('checked');
            if (checkbox.classList.contains('checked')) {
                checkbox.innerHTML = '‚úì';
                localStorage.setItem('mastered-vectors-in-c--98--your-comprehensive-guide', 'true');
            } else {
                checkbox.innerHTML = '';
                localStorage.setItem('mastered-vectors-in-c--98--your-comprehensive-guide', 'false');
            }
        }

        // Load mastery status
        const masteryStatus = localStorage.getItem('mastered-vectors-in-c--98--your-comprehensive-guide');
        if (masteryStatus === 'true') {
            const masteryCheckbox = document.querySelector('footer .checkbox');
            if (masteryCheckbox) {
                masteryCheckbox.classList.add('checked');
                masteryCheckbox.innerHTML = '‚úì';
            }
        }

        // Smooth scrolling
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            });
        });

        // Initialize CodeMirror for all code blocks
        let initAttempts = 0;
        const maxAttempts = 50; // Max 5 seconds of retries
        
        function initializeCodeMirror() {
            initAttempts++;
            
            // Check if CodeMirror is loaded
            if (typeof CodeMirror === 'undefined') {
                if (initAttempts >= maxAttempts) {
                    console.error('Failed to load CodeMirror after', maxAttempts, 'attempts. Using fallback styling.');
                    // Fallback: Style textareas as basic code blocks
                    document.querySelectorAll('.codemirror-code').forEach(textarea => {
                        textarea.style.fontFamily = 'Monaco, Menlo, "Ubuntu Mono", monospace';
                        textarea.style.fontSize = '14px';
                        textarea.style.lineHeight = '1.5';
                        textarea.style.padding = '10px';
                        textarea.style.border = '1px solid var(--border)';
                        textarea.style.borderRadius = '4px';
                        textarea.style.background = 'var(--code-bg)';
                        textarea.style.color = 'var(--code-text)';
                        textarea.style.resize = 'none';
                        textarea.style.minHeight = '100px';
                        textarea.readOnly = true;
                    });
                    return;
                }
                console.warn('CodeMirror not loaded, retrying in 100ms... (attempt', initAttempts, '/', maxAttempts, ')');
                setTimeout(initializeCodeMirror, 100);
                return;
            }
            
            const codeTextareas = document.querySelectorAll('.codemirror-code');
            console.log('Initializing CodeMirror for', codeTextareas.length, 'code blocks');
            
            codeTextareas.forEach(textarea => {
                const codeBlock = textarea.closest('.code-block');
                const language = codeBlock.dataset.language;
                
                // Map language to CodeMirror mode
                let mode = 'text';
                switch(language) {
                    case 'c':
                    case 'cpp':
                    case 'c++':
                        mode = 'text/x-csrc';
                        break;
                    case 'javascript':
                    case 'js':
                        mode = 'javascript';
                        break;
                    case 'bash':
                    case 'shell':
                    case 'sh':
                        mode = 'shell';
                        break;
                    case 'css':
                        mode = 'css';
                        break;
                    case 'html':
                        mode = 'htmlmixed';
                        break;
                    case 'json':
                        mode = 'application/json';
                        break;
                    default:
                        mode = 'text';
                }
                
                // Use custom theme that respects CSS variables
                const cmTheme = 'default'; // We'll override with CSS
                
                try {
                    const editor = CodeMirror.fromTextArea(textarea, {
                        mode: mode,
                        theme: cmTheme,
                        lineNumbers: true,
                        readOnly: 'nocursor',  // Disable cursor and selection
                        lineWrapping: true,    // Enable line wrapping to avoid horizontal scroll
                        scrollbarStyle: 'null', // Remove scrollbars
                        viewportMargin: Infinity, // Show all content without scrolling
                        matchBrackets: false,  // Disable bracket matching highlights
                        styleActiveLine: false, // Disable active line highlighting
                        indentUnit: 4,
                        tabSize: 4
                    });
                    
                    // Store editor reference for theme switching
                    textarea.codeMirrorInstance = editor;
                    
                    // Auto-refresh editor size and ensure no scrollbars
                    setTimeout(() => {
                        editor.refresh();
                        editor.setSize(null, 'auto'); // Auto-height based on content
                    }, 100);
                    
                    console.log('CodeMirror initialized for language:', language, 'mode:', mode);
                } catch (error) {
                    console.error('Failed to initialize CodeMirror for textarea:', error);
                }
            });
        }
        
        // CodeMirror themes are handled by CSS variables, no need to update programmatically
        
        // Initialize CodeMirror when DOM and scripts are fully loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                // Wait a bit more for all scripts to load
                setTimeout(initializeCodeMirror, 200);
            });
        } else {
            // Document already loaded, wait for scripts
            setTimeout(initializeCodeMirror, 200);
        }
    </script>
</body>
</html>