<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="../../imgs/favicon.png" type="image/x-icon">
    <link rel="stylesheet" href="../../style/main.css">
    <title>Sockets & Poll - Learning Guide</title>
</head>
<body>
        <header>
        <div class="container">
            <div class="header-content">
                <div class="header-title">
                    <h1>Sockets & Poll</h1>
                    <div class="author-info">By sel-mlil</div>
                </div>
                <div class="header-nav">
                    <a href="../../index.html" class="back-to-index">
                        Back to Index
                    </a>
                    <button class="theme-toggle" onclick="toggleTheme()">üåô Dark Mode</button>
                </div>
            </div>
        </div>
    </header>
        <nav>
        <div class="container">
            <div class="nav-grid">
                <a class="nav-item" href="#hook" data-section="0">üéØ The Hook</a>
                <a class="nav-item" href="#mechanics" data-section="1">‚öôÔ∏è How It Works</a>
                <a class="nav-item" href="#examples" data-section="2">üåç Real Examples</a>
                <a class="nav-item" href="#practice" data-section="3">üõ†Ô∏è Do This Now</a>
                <a class="nav-item" href="#warnings" data-section="4">‚ö†Ô∏è Avoid These</a>
                <a class="nav-item" href="#connections" data-section="5">üîó Connections</a>
                <a class="nav-item" href="#test" data-section="6">üéØ Test Yourself</a>
                <a class="nav-item" href="#growth" data-section="7">üìà Level Up</a>
            </div>
        </div>
    </nav>
        <main class="container">
        <section id="hook">
            <div class="section-header">
                <div class="section-icon hook">üéØ</div>
                <h2 class="section-title">THE HOOK</h2>
            </div>
            <div class="content">
                <p><strong>What is this?</strong><br>Sockets are endpoints for communication between processes over a network or within the same machine. <code>poll</code> lets you efficiently wait for multiple sockets to become ready for reading, writing, or errors.</p>
                <p><strong>Why care?</strong><br>Essential for building <strong>servers or networked applications</strong> to handle multiple clients without busy-waiting or blocking threads.</p>
                <p><strong>Mental model:</strong><br>Think of sockets like <strong>phone lines</strong>, each connecting to a friend. <code>poll</code> is like a receptionist telling you which lines are ringing, so you don't check each phone constantly.</p>
            </div>
        </section>

        <section id="mechanics">
            <div class="section-header">
                <div class="section-icon mechanics">‚öôÔ∏è</div>
                <h2 class="section-title">HOW IT WORKS</h2>
            </div>
            <div class="content">
                <h3>Core mechanics</h3>
                <ul>
                    <li><strong>Socket creation:</strong> <code>socket()</code> creates an endpoint for communication.</li>
                    <li><strong>Binding & Listening:</strong> Server sockets bind to an address and listen for connections.</li>
                    <li><strong>Poll monitoring:</strong> <code>poll()</code> watches multiple file descriptors for events without blocking.</li>
                </ul>
                <h3>Key components</h3>
                <ul>
                    <li><strong>File descriptors:</strong> Sockets are treated as file descriptors in Unix-like systems.</li>
                    <li><strong>Events:</strong> POLLIN (data ready to read), POLLOUT (ready for write), POLLERR (error condition).</li>
                    <li><strong>Timeout:</strong> <code>poll()</code> can wait indefinitely, return immediately, or timeout after a specified duration.</li>
                    <li><strong>Non-blocking I/O:</strong> Sockets can be set to non-blocking mode to avoid hanging operations.</li>
                </ul>
                <h3>Governing principles</h3>
                <ol>
                    <li>One socket per connection endpoint.</li>
                    <li>Poll checks multiple sockets in a single system call.</li>
                    <li>Events are edge-triggered or level-triggered depending on the system.</li>
                </ol>
            </div>
        </section>

        <section id="examples">
            <div class="section-header">
                <div class="section-icon examples">üåç</div>
                <h2 class="section-title">REAL EXAMPLES</h2>
            </div>
            <div class="content">
                <h3>Basic TCP Server</h3>
                <div class="code-block">
                    <pre>int server_fd = socket(AF_INET, SOCK_STREAM, 0);
struct sockaddr_in addr = {0};
addr.sin_family = AF_INET;
addr.sin_addr.s_addr = INADDR_ANY;
addr.sin_port = htons(8080);

bind(server_fd, (struct sockaddr*)&addr, sizeof(addr));
listen(server_fd, 10);</pre>
                </div>
                <h3>Poll-based event loop</h3>
                <div class="code-block">
                    <pre>struct pollfd fds[MAX_CLIENTS];
fds[0].fd = server_fd;
fds[0].events = POLLIN;
int nfds = 1;

while (1) {
    int ready = poll(fds, nfds, -1);
    
    if (fds[0].revents & POLLIN) {
        // Accept new connection
        int client_fd = accept(server_fd, NULL, NULL);
        fds[nfds].fd = client_fd;
        fds[nfds].events = POLLIN;
        nfds++;
    }
    
    for (int i = 1; i < nfds; i++) {
        if (fds[i].revents & POLLIN) {
            // Handle client data
            char buffer[1024];
            recv(fds[i].fd, buffer, sizeof(buffer), 0);
        }
    }
}</pre>
                </div>
                <h3>Edge case: Connection cleanup</h3>
                <div class="code-block">
                    <pre>if (fds[i].revents & (POLLHUP | POLLERR)) {
    close(fds[i].fd);
    // Remove from poll array
    for (int j = i; j < nfds - 1; j++) {
        fds[j] = fds[j + 1];
    }
    nfds--;
    i--; // Adjust index
}</pre>
                </div>
            </div>
        </section>

        <section id="practice">
            <div class="section-header">
                <div class="section-icon practice">üõ†Ô∏è</div>
                <h2 class="section-title">DO THIS NOW</h2>
            </div>
            <div class="content">
                <div class="action-box">
                <ol>
                    <li>Create a simple echo server:</li>
                </ol>
                <div class="code-block">
                    <pre>#include <sys/socket.h>
#include <sys/poll.h>
#include <netinet/in.h>
#include <stdio.h>
#include <unistd.h>

int main() {
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    // Set up address, bind, listen
    
    struct pollfd fds[10];
    fds[0].fd = server_fd;
    fds[0].events = POLLIN;
    
    while (1) {
        poll(fds, 1, -1);
        // Handle connections and data
    }
}</pre>
                </div>
                <ol start="2">
                    <li>Test with <code>telnet localhost 8080</code></li>
                    <li>Add multiple client support using poll array.</li>
                </ol>
                <p><strong>What to look for:</strong> How poll eliminates busy-waiting.<br><strong>Quick win:</strong> See one server handle multiple clients efficiently.</p>
                </div>
            </div>
        </section>

        <section id="warnings">
            <div class="section-header">
                <div class="section-icon warnings">‚ö†Ô∏è</div>
                <h2 class="section-title">AVOID THESE</h2>
            </div>
            <div class="content">
                <div class="warning-box">
                <ul>
                    <li><strong>Blocking operations in poll loop</strong> ‚Üí Always use non-blocking sockets or handle partial reads/writes.</li>
                    <li><strong>Not handling POLLHUP/POLLERR</strong> ‚Üí Disconnected clients will consume CPU if not removed.</li>
                    <li><strong>Fixed-size poll arrays</strong> ‚Üí Consider dynamic resizing or use epoll/kqueue for scalability.</li>
                </ul>
                </div>
            </div>
        </section>

        <section id="connections">
            <div class="section-header">
                <div class="section-icon connections">üîó</div>
                <h2 class="section-title">CONNECTIONS</h2>
            </div>
            <div class="content">
                <ul>
                    <li><strong>Prerequisites:</strong> File descriptors, system calls, basic networking concepts.</li>
                    <li><strong>Related concepts:</strong> select(), epoll (Linux), kqueue (BSD), async I/O patterns.</li>
                    <li><strong>Next steps:</strong> Study epoll for high-performance servers, non-blocking I/O patterns, and protocol design.</li>
                </ul>
            </div>
        </section>

        <section id="test">
            <div class="section-header">
                <div class="section-icon test">üéØ</div>
                <h2 class="section-title">TEST YOURSELF</h2>
            </div>
            <div class="content">
                <ol>
                    <li>What's the difference between poll() and busy-waiting on socket reads?</li>
                    <li>How do you handle a client disconnect in a poll-based server?</li>
                    <li>Why might poll() return without any file descriptors being ready?</li>
                </ol>
                <p><strong>Success criteria:</strong> You can build a multi-client server that doesn't waste CPU cycles.<br><strong>Review triggers:</strong> When building any networked application or real-time system.</p>
            </div>
        </section>

        <section id="growth">
            <div class="section-header">
                <div class="section-icon growth">üìà</div>
                <h2 class="section-title">LEVEL UP</h2>
            </div>
            <div class="content">
                <ul>
                    <li><strong>This week:</strong> Build an echo server, then a simple chat server using poll.</li>
                    <li><strong>This month:</strong> Learn epoll (Linux) or kqueue (BSD) for higher performance.</li>
                    <li><strong>Long term:</strong> Master async programming patterns, protocol design, and high-concurrency architectures.</li>
                </ul>
            </div>
        </section>
    </main>
        <footer>
        <div class="container">
            <p>Learning journey completed! üéâ</p>
            <div class="checkbox-item" style="justify-content: center; margin-top: 1rem;">
                <div class="checkbox" onclick="toggleComplete(this)"></div>
                <span>Mark this topic as mastered</span>
            </div>
        </div>
    </footer>
        <script>
        // Theme toggle
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            
            // Update button text
            updateThemeButton(newTheme);
        }

        // Update theme button text based on current theme
        function updateThemeButton(currentTheme) {
            const button = document.querySelector('.theme-toggle');
            if (currentTheme === 'dark') {
                button.innerHTML = '‚òÄÔ∏è Light Mode';
            } else {
                button.innerHTML = 'üåô Dark Mode';
            }
        }

        // Load saved theme
        function loadTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            updateThemeButton(savedTheme);
        }

        // Initialize theme on page load
        document.addEventListener('DOMContentLoaded', loadTheme);

        // Section completion
        document.querySelectorAll('.nav-item').forEach(item => {
            item.addEventListener('click', function() {
                this.classList.toggle('completed');
                const completedSections = Array.from(document.querySelectorAll('.nav-item.completed'))
                    .map(el => el.getAttribute('data-section'));
                localStorage.setItem('completed-sockets---poll', JSON.stringify(completedSections));
            });
        });

        // Load saved progress
        const savedProgress = localStorage.getItem('completed-sockets---poll');
        if (savedProgress) {
            const completed = JSON.parse(savedProgress);
            completed.forEach(sectionNum => {
                const navItem = document.querySelector(`[data-section="${sectionNum}"]`);
                if (navItem) navItem.classList.add('completed');
            });
        }

        // Checkbox functionality
        function toggleComplete(checkbox) {
            checkbox.classList.toggle('checked');
            if (checkbox.classList.contains('checked')) {
                checkbox.innerHTML = '‚úì';
                localStorage.setItem('mastered-sockets---poll', 'true');
            } else {
                checkbox.innerHTML = '';
                localStorage.setItem('mastered-sockets---poll', 'false');
            }
        }

        // Load mastery status
        const masteryStatus = localStorage.getItem('mastered-sockets---poll');
        if (masteryStatus === 'true') {
            const masteryCheckbox = document.querySelector('footer .checkbox');
            if (masteryCheckbox) {
                masteryCheckbox.classList.add('checked');
                masteryCheckbox.innerHTML = '‚úì';
            }
        }

        // Smooth scrolling
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            });
        });
    </script>
</body>
</html>